packageobservabilityimport("context""crypto/rand""encoding/hex""fmt""net/http""strconv""strings""sync""time"chimw"github.com/go-chi/chi/v5/middleware""github.com/rs/zerolog")//───Trace/SpanTypes────────────────────────────────────//TraceIDisa128-bittraceidentifier.typeTraceID[16]bytefunc(tTraceID)String()string{returnhex.EncodeToString(t[:])}//SpanIDisa64-bitspanidentifier.typeSpanID[8]bytefunc(sSpanID)String()string{returnhex.EncodeToString(s[:])}//GenerateTraceIDcreatesanewrandomtraceID.funcGenerateTraceID()TraceID{varidTraceID_,_=rand.Read(id[:])returnid}//GenerateSpanIDcreatesanewrandomspanID.funcGenerateSpanID()SpanID{varidSpanID_,_=rand.Read(id[:])returnid}//SpanContextholdstracepropagationdata.typeSpanContextstruct{TraceIDTraceIDSpanIDSpanIDParentIDSpanIDSampledbool}//Spanrepresentsasingleoperationinadistributedtrace.typeSpanstruct{musync.MutexNamestringContextSpanContextStartTimetime.TimeEndTimetime.TimeAttributesmap[string]stringEvents[]SpanEventStatusCodestring//"OK","ERROR","UNSET"StatusMsgstringfinishedbool}//SpanEventisatime-stampedannotationonaspan.typeSpanEventstruct{NamestringTimestamptime.TimeAttributesmap[string]string}//SetAttributeaddsakey-valueattributetothespan.func(s*Span)SetAttribute(key,valuestring){s.mu.Lock()defers.mu.Unlock()s.Attributes[key]=value}//AddEventaddsatimestampedeventtothespan.func(s*Span)AddEvent(namestring,attrsmap[string]string){s.mu.Lock()defers.mu.Unlock()s.Events=append(s.Events,SpanEvent{Name:name,Timestamp:time.Now().UTC(),Attributes:attrs,})}//SetStatussetsthespan'sstatus.func(s*Span)SetStatus(code,msgstring){s.mu.Lock()defers.mu.Unlock()s.StatusCode=codes.StatusMsg=msg}//Endmarksthespanasfinished.func(s*Span)End(){s.mu.Lock()defers.mu.Unlock()if!s.finished{s.EndTime=time.Now().UTC()s.finished=true}}//Durationreturnsthespanduration.func(s*Span)Duration()time.Duration{s.mu.Lock()defers.mu.Unlock()ifs.finished{returns.EndTime.Sub(s.StartTime)}returntime.Since(s.StartTime)}//───TraceContextPropagation(W3CTraceparent)────────────//ParseTraceparentextractstracecontextfromtheW3CTraceparentheader.//Format:00-{trace_id}-{parent_id}-{flags}funcParseTraceparent(headerstring)(*SpanContext,error){parts:=strings.Split(header,"-")iflen(parts)!=4||parts[0]!="00"{returnnil,fmt.Errorf("invalidtraceparentformat")}traceBytes,err:=hex.DecodeString(parts[1])iferr!=nil||len(traceBytes)!=16{returnnil,fmt.Errorf("invalidtraceID")}parentBytes,err:=hex.DecodeString(parts[2])iferr!=nil||len(parentBytes)!=8{returnnil,fmt.Errorf("invalidparentID")}vartraceIDTraceIDvarparentIDSpanIDcopy(traceID[:],traceBytes)copy(parentID[:],parentBytes)sampled:=parts[3]=="01"return&SpanContext{TraceID:traceID,ParentID:parentID,Sampled:sampled,},nil}//FormatTraceparentcreatesaW3CTraceparentheadervalue.funcFormatTraceparent(ctxSpanContext)string{flags:="00"ifctx.Sampled{flags="01"}returnfmt.Sprintf("00-%s-%s-%s",ctx.TraceID,ctx.SpanID,flags)}//───Tracer─────────────────────────────────────────────────//SpanExporterreceivescompletedspansforexporttoabackend.typeSpanExporterinterface{Export(spans[]*Span)errorShutdown()error}//Tracercreatesandmanagesdistributedtracespans.typeTracerstruct{musync.Mutexloggerzerolog.LoggerexporterSpanExportersamplerfloat64//0.0-1.0samplingratebuffer[]*SpanbufSizeintstopChchanstruct{}//signalsperiodicflushgoroutinetostop}//NewTracercreatesanewdistributedtracer.funcNewTracer(loggerzerolog.Logger,exporterSpanExporter,sampleRatefloat64)*Tracer{ifsampleRate<=0{sampleRate=1.0//default:sampleeverything}t:=&Tracer{logger:logger.With().Str("component","tracer").Logger(),exporter:exporter,sampler:sampleRate,buffer:make([]*Span,0,1000),bufSize:1000,stopCh:make(chanstruct{}),}//Startperiodicflushtoavoidspanslingeringinmemoryunderlowtraffic.got.periodicFlush()returnt}//periodicFlushdrainsthespanbufferevery10seconds.func(t*Tracer)periodicFlush(){ticker:=time.NewTicker(10*time.Second)deferticker.Stop()for{select{case<-ticker.C:t.flush()case<-t.stopCh:return}}}//Stopshutsdowntheperiodicflushgoroutineandexportsremainingspans.func(t*Tracer)Stop(){close(t.stopCh)t.flush()}//StartSpancreatesanewspan.func(t*Tracer)StartSpan(namestring,parent*SpanContext)*Span{span:=&Span{Name:name,StartTime:time.Now().UTC(),Attributes:make(map[string]string),StatusCode:"UNSET",}ifparent!=nil{span.Context=SpanContext{TraceID:parent.TraceID,SpanID:GenerateSpanID(),ParentID:parent.SpanID,Sampled:parent.Sampled,}}else{//Applysamplingrateforrootspans.sampled:=t.sampler>=1.0if!sampled&&t.sampler>0{//UsedeterministicsamplingbasedontraceID.traceID:=GenerateTraceID()//Usethelast4bytesoftraceIDfordeterministicsampling.iflen(traceID)>=4{v:=uint32(traceID[len(traceID)-1])|uint32(traceID[len(traceID)-2])<<8sampled=float64(v)/float64(0xFFFF)<t.sampler}span.Context=SpanContext{TraceID:traceID,SpanID:GenerateSpanID(),Sampled:sampled,}}else{span.Context=SpanContext{TraceID:GenerateTraceID(),SpanID:GenerateSpanID(),Sampled:sampled,}}}returnspan}//EndSpanfinishesaspanandbuffersitforexport.func(t*Tracer)EndSpan(span*Span){span.End()if!span.Context.Sampled{return}t.mu.Lock()t.buffer=append(t.buffer,span)shouldFlush:=len(t.buffer)>=t.bufSizet.mu.Unlock()ifshouldFlush{t.flush()}}func(t*Tracer)flush(){t.mu.Lock()iflen(t.buffer)==0{t.mu.Unlock()return}spans:=t.buffert.buffer=make([]*Span,0,t.bufSize)t.mu.Unlock()ift.exporter!=nil{iferr:=t.exporter.Export(spans);err!=nil{t.logger.Error().Err(err).Int("spans",len(spans)).Msg("spanexportfailed")}}}//Shutdownflushesremainingspansandclosestheexporter.func(t*Tracer)Shutdown(){t.flush()ift.exporter!=nil{_=t.exporter.Shutdown()}}//───LogExporter(development)─────────────────────────────//LogExporterwritesspansasstructuredlogentries.typeLogExporterstruct{loggerzerolog.Logger}funcNewLogExporter(loggerzerolog.Logger)*LogExporter{return&LogExporter{logger:logger.With().Str("exporter","log").Logger()}}func(e*LogExporter)Export(spans[]*Span)error{for_,s:=rangespans{e.logger.Debug().Str("name",s.Name).Str("trace_id",s.Context.TraceID.String()).Str("span_id",s.Context.SpanID.String()).Str("parent_id",s.Context.ParentID.String()).Dur("duration",s.Duration()).Str("status",s.StatusCode).Int("attributes",len(s.Attributes)).Int("events",len(s.Events)).Msg("span")}returnnil}func(e*LogExporter)Shutdown()error{returnnil}//───TracingContextKey───────────────────────────────────typetraceCtxKeystruct{}//SpanFromContextretrievesthecurrentspanfromcontext.funcSpanFromContext(ctxcontext.Context)*Span{ifs,ok:=ctx.Value(traceCtxKey{}).(*Span);ok{returns}returnnil}//ContextWithSpanstoresaspanincontext.funcContextWithSpan(ctxcontext.Context,span*Span)context.Context{returncontext.WithValue(ctx,traceCtxKey{},span)}//───TracingMiddleware─────────────────────────────────────//TracingMiddlewarecreatesspansforeachHTTPrequest.funcTracingMiddleware(tracer*Tracer)func(http.Handler)http.Handler{returnfunc(nexthttp.Handler)http.Handler{returnhttp.HandlerFunc(func(whttp.ResponseWriter,r*http.Request){//Extracttracecontextfromincomingrequestvarparent*SpanContextiftp:=r.Header.Get("Traceparent");tp!=""{parsed,err:=ParseTraceparent(tp)iferr==nil{parent=parsed}}//StartspanforthisrequestspanName:=fmt.Sprintf("%s%s",r.Method,r.URL.Path)span:=tracer.StartSpan(spanName,parent)//SetstandardHTTPattributesspan.SetAttribute("http.method",r.Method)span.SetAttribute("http.url",r.URL.String())span.SetAttribute("http.target",r.URL.Path)span.SetAttribute("http.host",r.Host)span.SetAttribute("http.user_agent",r.UserAgent())ifreqID:=chimw.GetReqID(r.Context());reqID!=""{span.SetAttribute("alfred.request_id",reqID)}//Propagatetracecontextdownstreamw.Header().Set("Traceparent",FormatTraceparent(span.Context))w.Header().Set("X-Alfred-Trace-ID",span.Context.TraceID.String())//Storespanincontextctx:=ContextWithSpan(r.Context(),span)//Wrapresponsewritertocapturestatuscoderw:=chimw.NewWrapResponseWriter(w,r.ProtoMajor)next.ServeHTTP(rw,r.WithContext(ctx))//Recordresponseattributesspan.SetAttribute("http.status_code",strconv.Itoa(rw.Status()))ifrw.Status()>=500{span.SetStatus("ERROR",fmt.Sprintf("HTTP%d",rw.Status()))}else{span.SetStatus("OK","")}//Finishspantracer.EndSpan(span)})}}