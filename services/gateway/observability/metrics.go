packageobservabilityimport("fmt""net/http""sort""strconv""strings""sync""sync/atomic""time""github.com/rs/zerolog")//───MetricTypes───────────────────────────────────────────//Counterisamonotonicallyincreasingvalue.typeCounterstruct{valueint64}func(c*Counter)Inc(){atomic.AddInt64(&c.value,1)}func(c*Counter)Add(nint64){atomic.AddInt64(&c.value,n)}func(c*Counter)Value()int64{returnatomic.LoadInt64(&c.value)}//Gaugeisavaluethatcangoupanddown.typeGaugestruct{valueint64//storedasmicrosforfloat-likeprecision}func(g*Gauge)Set(vfloat64){atomic.StoreInt64(&g.value,int64(v*1e6))}func(g*Gauge)Inc(){atomic.AddInt64(&g.value,1e6)}func(g*Gauge)Dec(){atomic.AddInt64(&g.value,-1e6)}func(g*Gauge)Value()float64{returnfloat64(atomic.LoadInt64(&g.value))/1e6}//Histogramtracksvaluedistributionswithconfigurablebuckets.typeHistogramstruct{musync.Mutexbuckets[]float64counts[]int64//per-bucketcounts(+Inf)sumfloat64countint64}funcNewHistogram(buckets[]float64)*Histogram{sorted:=make([]float64,len(buckets))copy(sorted,buckets)sort.Float64s(sorted)return&Histogram{buckets:sorted,counts:make([]int64,len(sorted)+1),//+1for+Inf}}func(h*Histogram)Observe(vfloat64){h.mu.Lock()deferh.mu.Unlock()h.sum+=vh.count++//Storedifferentialcounts—onlyincrementthefirstmatchingbucket.//TheHandleraccumulatestheseintocumulativePrometheusbuckets.placed:=falsefori,b:=rangeh.buckets{ifv<=b{h.counts[i]++placed=truebreak}}if!placed{h.counts[len(h.buckets)]++//+Infbucket}}//───LabelKey──────────────────────────────────────────────//labelKeycreatesasortedlabelstringformetricidentification.//T208:Rewrittentousestrings.Builder—eliminates3sliceallocs//+Nfmt.Sprintfcallspermetricrecording.funclabelKey(labelsmap[string]string)string{iflen(labels)==0{return""}keys:=make([]string,0,len(labels))fork:=rangelabels{keys=append(keys,k)}sort.Strings(keys)varbstrings.Builderb.Grow(len(keys)*24)//estimateavgkey=valpairlengthfori,k:=rangekeys{ifi>0{b.WriteByte(',')}b.WriteString(k)b.WriteString(`="`)b.WriteString(labels[k])b.WriteByte('"')}returnb.String()}//───MetricsRegistry───────────────────────────────────────//MetricsisthecentralPrometheus-compatiblemetricsregistry.typeMetricsstruct{musync.RWMutexloggerzerolog.Loggercountersmap[string]map[string]*Counter//name→labelKey→countergaugesmap[string]map[string]*Gaugehistogramsmap[string]map[string]*Histogram//Pre-definedmetricnamesfordocumentation//(actualregistrationisimplicitonfirstuse)//Defaulthistogrambucketsforlatency(ms)latencyBuckets[]float64//DefaulthistogrambucketsfortokencountstokenBuckets[]float64}//NewMetricscreatesanewmetricsregistry.funcNewMetrics(loggerzerolog.Logger)*Metrics{return&Metrics{logger:logger.With().Str("component","metrics").Logger(),counters:make(map[string]map[string]*Counter),gauges:make(map[string]map[string]*Gauge),histograms:make(map[string]map[string]*Histogram),latencyBuckets:[]float64{5,10,25,50,100,250,500,1000,2500,5000,10000},tokenBuckets:[]float64{10,50,100,500,1000,5000,10000,50000},}}//───CounterOperations─────────────────────────────────────func(m*Metrics)CounterInc(namestring,labelsmap[string]string){m.getCounter(name,labels).Inc()}func(m*Metrics)CounterAdd(namestring,labelsmap[string]string,nint64){m.getCounter(name,labels).Add(n)}func(m*Metrics)getCounter(namestring,labelsmap[string]string)*Counter{key:=labelKey(labels)m.mu.RLock()ifbyName,ok:=m.counters[name];ok{ifc,ok:=byName[key];ok{m.mu.RUnlock()returnc}}m.mu.RUnlock()m.mu.Lock()deferm.mu.Unlock()if_,ok:=m.counters[name];!ok{m.counters[name]=make(map[string]*Counter)}if_,ok:=m.counters[name][key];!ok{m.counters[name][key]=&Counter{}}returnm.counters[name][key]}//───GaugeOperations───────────────────────────────────────func(m*Metrics)GaugeSet(namestring,labelsmap[string]string,vfloat64){m.getGauge(name,labels).Set(v)}func(m*Metrics)GaugeInc(namestring,labelsmap[string]string){m.getGauge(name,labels).Inc()}func(m*Metrics)GaugeDec(namestring,labelsmap[string]string){m.getGauge(name,labels).Dec()}func(m*Metrics)getGauge(namestring,labelsmap[string]string)*Gauge{key:=labelKey(labels)m.mu.RLock()ifbyName,ok:=m.gauges[name];ok{ifg,ok:=byName[key];ok{m.mu.RUnlock()returng}}m.mu.RUnlock()m.mu.Lock()deferm.mu.Unlock()if_,ok:=m.gauges[name];!ok{m.gauges[name]=make(map[string]*Gauge)}if_,ok:=m.gauges[name][key];!ok{m.gauges[name][key]=&Gauge{}}returnm.gauges[name][key]}//───HistogramOperations───────────────────────────────────func(m*Metrics)HistogramObserve(namestring,labelsmap[string]string,vfloat64){m.getHistogram(name,labels).Observe(v)}func(m*Metrics)getHistogram(namestring,labelsmap[string]string)*Histogram{key:=labelKey(labels)m.mu.RLock()ifbyName,ok:=m.histograms[name];ok{ifh,ok:=byName[key];ok{m.mu.RUnlock()returnh}}m.mu.RUnlock()m.mu.Lock()deferm.mu.Unlock()if_,ok:=m.histograms[name];!ok{m.histograms[name]=make(map[string]*Histogram)}if_,ok:=m.histograms[name][key];!ok{m.histograms[name][key]=NewHistogram(m.latencyBuckets)}returnm.histograms[name][key]}//───Pre-definedMetricHelpers─────────────────────────────//TrackRequestrecordsacompletedrequestwithallrelevantlabels.func(m*Metrics)TrackRequest(provider,model,endpointstring,statusCodeint,latencyMsfloat64,tokensint64,cachedbool){labels:=map[string]string{"provider":provider,"model":model,"endpoint":endpoint,"status":strconv.Itoa(statusCode),}m.CounterInc("alfred_gateway_requests_total",labels)m.HistogramObserve("alfred_gateway_request_duration_ms",labels,latencyMs)m.CounterAdd("alfred_gateway_tokens_total",labels,tokens)ifcached{m.CounterInc("alfred_gateway_cache_hits_total",map[string]string{"provider":provider,"model":model,})}}//TrackWalletOperationrecordsawalletcreditoperation.func(m*Metrics)TrackWalletOperation(opType,walletTypestring,amountfloat64){labels:=map[string]string{"type":opType,"wallet_type":walletType}m.CounterInc("alfred_wallet_operations_total",labels)}//TrackProviderHealthrecordsproviderhealthstatus.func(m*Metrics)TrackProviderHealth(providerstring,healthybool){val:=0.0ifhealthy{val=1.0}m.GaugeSet("alfred_provider_healthy",map[string]string{"provider":provider},val)}//TrackSafetyViolationrecordsasafetypipelineviolation.func(m*Metrics)TrackSafetyViolation(category,severitystring){m.CounterInc("alfred_safety_violations_total",map[string]string{"category":category,"severity":severity,})}//───PrometheusExpositionFormat───────────────────────────//Handlerreturnsanhttp.HandlerFuncthatserves/metricsin//Prometheustextexpositionformat.func(m*Metrics)Handler()http.HandlerFunc{returnfunc(whttp.ResponseWriter,r*http.Request){w.Header().Set("Content-Type","text/plain;version=0.0.4;charset=utf-8")varsbstrings.Builder//Timestampsb.WriteString(fmt.Sprintf("#AlfredGatewayMetrics-%s\n\n",time.Now().UTC().Format(time.RFC3339)))m.mu.RLock()deferm.mu.RUnlock()//Countersforname,byLabel:=rangem.counters{sb.WriteString(fmt.Sprintf("#TYPE%scounter\n",name))forlk,c:=rangebyLabel{iflk==""{sb.WriteString(fmt.Sprintf("%s%d\n",name,c.Value()))}else{sb.WriteString(fmt.Sprintf("%s{%s}%d\n",name,lk,c.Value()))}}sb.WriteString("\n")}//Gaugesforname,byLabel:=rangem.gauges{sb.WriteString(fmt.Sprintf("#TYPE%sgauge\n",name))forlk,g:=rangebyLabel{iflk==""{sb.WriteString(fmt.Sprintf("%s%f\n",name,g.Value()))}else{sb.WriteString(fmt.Sprintf("%s{%s}%f\n",name,lk,g.Value()))}}sb.WriteString("\n")}//Histogramsforname,byLabel:=rangem.histograms{sb.WriteString(fmt.Sprintf("#TYPE%shistogram\n",name))forlk,h:=rangebyLabel{h.mu.Lock()prefix:=nameiflk!=""{prefix=fmt.Sprintf("%s{%s}",name,lk)}cumulative:=int64(0)fori,b:=rangeh.buckets{cumulative+=h.counts[i]iflk!=""{sb.WriteString(fmt.Sprintf("%s_bucket{le=\"%g\",%s}%d\n",name,b,lk,cumulative))}else{sb.WriteString(fmt.Sprintf("%s_bucket{le=\"%g\"}%d\n",name,b,cumulative))}}cumulative+=h.counts[len(h.buckets)]iflk!=""{sb.WriteString(fmt.Sprintf("%s_bucket{le=\"+Inf\",%s}%d\n",name,lk,cumulative))}else{sb.WriteString(fmt.Sprintf("%s_bucket{le=\"+Inf\"}%d\n",name,cumulative))}sb.WriteString(fmt.Sprintf("%s_sum%f\n",prefix,h.sum))sb.WriteString(fmt.Sprintf("%s_count%d\n",prefix,h.count))h.mu.Unlock()}sb.WriteString("\n")}_,_=w.Write([]byte(sb.String()))}}