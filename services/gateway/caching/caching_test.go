packagecaching_testimport("context""encoding/json""math""testing""time""github.com/AlfredDev/alfred/services/gateway/caching""github.com/rs/zerolog")//mockEmbeddingreturnsasimpledeterministicembeddingfortesting.funcmockEmbedFn(ctxcontext.Context,text,modelstring)([]float64,error){//Simplehash-basedembedding:mapcharacterstovectorpositionsvec:=make([]float64,8)fori,ch:=rangetext{vec[i%8]+=float64(ch)/1000.0}//Normalizevarnormfloat64for_,v:=rangevec{norm+=v*v}norm=math.Sqrt(norm)ifnorm>0{fori:=rangevec{vec[i]/=norm}}returnvec,nil}funcnewTestCacheEngine(cfg...caching.CacheConfig)*caching.Engine{iflen(cfg)>0{returncaching.NewEngine(zerolog.Nop(),mockEmbedFn,cfg[0])}returncaching.NewEngine(zerolog.Nop(),mockEmbedFn)}//──DefaultCacheConfig──────────────────────────────────────funcTestDefaultCacheConfig(t*testing.T){cfg:=caching.DefaultCacheConfig()ifcfg.SimilarityThreshold!=0.92{t.Errorf("expectedsimilaritythreshold0.92,got%f",cfg.SimilarityThreshold)}ifcfg.DefaultTTL!=24*time.Hour{t.Errorf("expected24hTTL,got%v",cfg.DefaultTTL)}ifcfg.MaxEntries!=10000{t.Errorf("expectedmax10000,got%d",cfg.MaxEntries)}if!cfg.ValidateResponses{t.Error("responsevalidationshouldbeenabledbydefault")}}//──StoreandLookup────────────────────────────────────────funcTestStore_CreatesEntry(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})entry,err:=e.Store(ctx,"team-1","gpt-4","WhatisGo?",resp,100)iferr!=nil{t.Fatalf("storefailed:%v",err)}ifentry.Namespace!="team-1"{t.Errorf("expectednamespace'team-1',got%q",entry.Namespace)}ifentry.TokensSaved!=100{t.Errorf("expectedtokens_saved=100,got%d",entry.TokensSaved)}}funcTestLookup_ExactMatch(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"team-1","gpt-4","WhatisGo?",resp,100)result,err:=e.Lookup(ctx,"team-1","gpt-4","WhatisGo?")iferr!=nil{t.Fatalf("lookupfailed:%v",err)}if!result.Hit{t.Error("expectedcachehitforexactsameprompt")}ifresult.Source!="exact"{t.Errorf("expectedsource'exact',got%q",result.Source)}ifresult.Similarity!=1.0{t.Errorf("exactmatchshouldhavesimilarity1.0,got%f",result.Similarity)}}funcTestLookup_CacheMiss(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()result,err:=e.Lookup(ctx,"team-1","gpt-4","neverstoredprompt")iferr!=nil{t.Fatalf("lookupfailed:%v",err)}ifresult.Hit{t.Error("expectedcachemissforunstoredprompt")}}//──NamespaceIsolation─────────────────────────────────────funcTestLookup_NamespaceIsolation(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"team-a","gpt-4","secretquestion",resp,50)//Differentnamespaceshouldmissresult,_:=e.Lookup(ctx,"team-b","gpt-4","secretquestion")ifresult.Hit&&result.Source=="exact"{t.Error("differentnamespaceshouldnotgetexactmatchfromteam-a")}}//──CacheBypass────────────────────────────────────────────funcTestShouldBypass_CacheBypassHeader(t*testing.T){headers:=map[string]string{"X-Cache-Bypass":"true"}if!caching.ShouldBypass(headers){t.Error("X-Cache-Bypass:trueshouldtriggerbypass")}}funcTestShouldBypass_CacheControl(t*testing.T){headers:=map[string]string{"Cache-Control":"no-cache"}if!caching.ShouldBypass(headers){t.Error("Cache-Control:no-cacheshouldtriggerbypass")}}funcTestShouldBypass_NormalHeaders(t*testing.T){headers:=map[string]string{"Content-Type":"application/json"}ifcaching.ShouldBypass(headers){t.Error("normalheadersshouldnottriggerbypass")}}funcTestShouldBypass_EmptyHeaders(t*testing.T){ifcaching.ShouldBypass(map[string]string{}){t.Error("emptyheadersshouldnottriggerbypass")}}//──Invalidation────────────────────────────────────────────funcTestInvalidate_ExistingEntry(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})entry,_:=e.Store(ctx,"ns","gpt-4","testprompt",resp,10)removed:=e.Invalidate("ns",entry.ID)if!removed{t.Error("invalidateshouldreturntrueforexistingentry")}//Verifyit'sgoneresult,_:=e.Lookup(ctx,"ns","gpt-4","testprompt")ifresult.Hit&&result.Source=="exact"{t.Error("invalidatedentryshouldnotreturnexacthit")}}funcTestInvalidate_NonexistentEntry(t*testing.T){e:=newTestCacheEngine()removed:=e.Invalidate("ns","nonexistent-id")ifremoved{t.Error("invalidateshouldreturnfalsefornonexistententry")}}//──FlushNamespace──────────────────────────────────────────funcTestFlushNamespace(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"flush-ns","gpt-4","prompt1",resp,10)e.Store(ctx,"flush-ns","gpt-4","prompt2",resp,20)count:=e.FlushNamespace("flush-ns")ifcount!=2{t.Errorf("expected2flushed,got%d",count)}}//──FlushAll────────────────────────────────────────────────funcTestFlushAll(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"ns-1","gpt-4","p1",resp,10)e.Store(ctx,"ns-2","gpt-4","p2",resp,20)count:=e.FlushAll()ifcount!=2{t.Errorf("expected2flushedacrossnamespaces,got%d",count)}}//──Stats───────────────────────────────────────────────────funcTestStats_InitiallyZero(t*testing.T){e:=newTestCacheEngine()stats:=e.Stats()ifstats.Hits!=0||stats.Misses!=0||stats.Evictions!=0{t.Error("initialstatsshouldbezero")}ifstats.Entries!=0{t.Errorf("initialentriesshouldbe0,got%d",stats.Entries)}}funcTestStats_TracksHitsAndMisses(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()//Cachemisse.Lookup(ctx,"ns","gpt-4","unknown")stats:=e.Stats()ifstats.Misses!=1{t.Errorf("expected1miss,got%d",stats.Misses)}//Storeandhitresp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"ns","gpt-4","storedprompt",resp,50)e.Lookup(ctx,"ns","gpt-4","storedprompt")stats=e.Stats()ifstats.Hits!=1{t.Errorf("expected1hit,got%d",stats.Hits)}}funcTestStats_TracksEntries(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"ns","gpt-4","p1",resp,10)e.Store(ctx,"ns","gpt-4","p2",resp,20)stats:=e.Stats()ifstats.Entries!=2{t.Errorf("expected2entries,got%d",stats.Entries)}}funcTestStats_TracksEvictions(t*testing.T){cfg:=caching.DefaultCacheConfig()cfg.MaxEntries=2//Verysmallcachee:=newTestCacheEngine(cfg)ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"ns","gpt-4","p1",resp,10)e.Store(ctx,"ns","gpt-4","p2",resp,20)e.Store(ctx,"ns","gpt-4","p3",resp,30)//Shouldevictoldeststats:=e.Stats()ifstats.Evictions<1{t.Errorf("expectedatleast1eviction,got%d",stats.Evictions)}}funcTestStats_HitRateCalculation(t*testing.T){e:=newTestCacheEngine()ctx:=context.Background()resp,_:=json.Marshal(map[string]interface{}{"choices":[]interface{}{map[string]interface{}{"text":"hello"}},})e.Store(ctx,"ns","gpt-4","test",resp,50)//1miss+1hit=50%hitratee.Lookup(ctx,"ns","gpt-4","nonexistent")e.Lookup(ctx,"ns","gpt-4","test")stats:=e.Stats()ifstats.HitRate<49||stats.HitRate>51{t.Errorf("expected~50%%hitrate,got%.2f%%",stats.HitRate)}}