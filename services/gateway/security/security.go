packagesecurityimport("context""crypto/aes""crypto/cipher""crypto/rand""crypto/tls""crypto/x509""encoding/base64""encoding/json""fmt""io""net/http""os""strings""sync""time")//───T192:HashiCorpVaultIntegration──────────────────────typeVaultConfigstruct{Enabledbool`json:"enabled"`Addressstring`json:"address"`//e.g.,"https://vault.internal:8200"Tokenstring`json:"-"`//NeverlogMountPathstring`json:"mount_path"`//e.g.,"secret"Namespacestring`json:"namespace"`RenewTTLtime.Duration`json:"renew_ttl"`MaxRetriesint`json:"max_retries"`}typeVaultClientstruct{configVaultConfigclient*http.Clientmusync.RWMutexcachemap[string]*cachedSecret}typecachedSecretstruct{Valuemap[string]stringExpiresAttime.Time}funcNewVaultClient(configVaultConfig)*VaultClient{ifconfig.MountPath==""{config.MountPath="secret"}ifconfig.MaxRetries==0{config.MaxRetries=3}ifconfig.RenewTTL==0{config.RenewTTL=5*time.Minute}return&VaultClient{config:config,client:&http.Client{Timeout:10*time.Second},cache:make(map[string]*cachedSecret),}}//GetProviderKeyretrievesaproviderAPIkeyfromVault.func(v*VaultClient)GetProviderKey(ctxcontext.Context,providerstring)(string,error){if!v.config.Enabled{//FallbacktoenvvarenvKey:=fmt.Sprintf("%s_API_KEY",strings.ToUpper(provider))ifkey:=os.Getenv(envKey);key!=""{returnkey,nil}return"",fmt.Errorf("vaultdisabledandnoenvvar%s",envKey)}path:=fmt.Sprintf("providers/%s",provider)//Checkcachev.mu.RLock()ifcached,ok:=v.cache[path];ok&&time.Now().Before(cached.ExpiresAt){v.mu.RUnlock()returncached.Value["api_key"],nil}v.mu.RUnlock()//FetchfromVaultsecret,err:=v.readSecret(ctx,path)iferr!=nil{return"",fmt.Errorf("readproviderkey:%w",err)}apiKey,ok:=secret["api_key"]if!ok{return"",fmt.Errorf("noapi_keyfieldinvaultpath%s",path)}//Cachev.mu.Lock()v.cache[path]=&cachedSecret{Value:secret,ExpiresAt:time.Now().Add(v.config.RenewTTL),}v.mu.Unlock()returnapiKey,nil}//WriteProviderKeystoresaproviderAPIkeyinVault.func(v*VaultClient)WriteProviderKey(ctxcontext.Context,provider,apiKeystring)error{path:=fmt.Sprintf("providers/%s",provider)data:=map[string]string{"api_key":apiKey}returnv.writeSecret(ctx,path,data)}//RotateProviderKeyreplacesthekeyandreturnsthenewone.func(v*VaultClient)RotateProviderKey(ctxcontext.Context,provider,newKeystring)error{iferr:=v.WriteProviderKey(ctx,provider,newKey);err!=nil{returnfmt.Errorf("rotatekey:%w",err)}//Invalidatecachev.mu.Lock()path:=fmt.Sprintf("providers/%s",provider)delete(v.cache,path)v.mu.Unlock()returnnil}//ListProvidersreturnsallstoredprovidernames.func(v*VaultClient)ListProviders(ctxcontext.Context)([]string,error){if!v.config.Enabled{returnnil,fmt.Errorf("vaultnotenabled")}url:=fmt.Sprintf("%s/v1/%s/metadata/providers?list=true",v.config.Address,v.config.MountPath)req,err:=http.NewRequestWithContext(ctx,http.MethodGet,url,nil)iferr!=nil{returnnil,err}req.Header.Set("X-Vault-Token",v.config.Token)ifv.config.Namespace!=""{req.Header.Set("X-Vault-Namespace",v.config.Namespace)}resp,err:=v.client.Do(req)iferr!=nil{returnnil,fmt.Errorf("vaultlist:%w",err)}deferresp.Body.Close()varresultstruct{Datastruct{Keys[]string`json:"keys"`}`json:"data"`}iferr:=json.NewDecoder(resp.Body).Decode(&result);err!=nil{returnnil,fmt.Errorf("decodevaultlist:%w",err)}returnresult.Data.Keys,nil}func(v*VaultClient)readSecret(ctxcontext.Context,pathstring)(map[string]string,error){url:=fmt.Sprintf("%s/v1/%s/data/%s",v.config.Address,v.config.MountPath,path)varlastErrerrorforattempt:=0;attempt<=v.config.MaxRetries;attempt++{req,err:=http.NewRequestWithContext(ctx,http.MethodGet,url,nil)iferr!=nil{returnnil,err}req.Header.Set("X-Vault-Token",v.config.Token)ifv.config.Namespace!=""{req.Header.Set("X-Vault-Namespace",v.config.Namespace)}resp,err:=v.client.Do(req)iferr!=nil{lastErr=errtime.Sleep(time.Duration(attempt+1)*100*time.Millisecond)continue}deferresp.Body.Close()ifresp.StatusCode==http.StatusNotFound{returnnil,fmt.Errorf("secretnotfound:%s",path)}ifresp.StatusCode!=http.StatusOK{body,_:=io.ReadAll(resp.Body)returnnil,fmt.Errorf("vaulterror(%d):%s",resp.StatusCode,string(body))}varresultstruct{Datastruct{Datamap[string]string`json:"data"`}`json:"data"`}iferr:=json.NewDecoder(resp.Body).Decode(&result);err!=nil{returnnil,fmt.Errorf("decodesecret:%w",err)}returnresult.Data.Data,nil}returnnil,fmt.Errorf("vaultreadfailedafter%dretries:%w",v.config.MaxRetries,lastErr)}func(v*VaultClient)writeSecret(ctxcontext.Context,pathstring,datamap[string]string)error{url:=fmt.Sprintf("%s/v1/%s/data/%s",v.config.Address,v.config.MountPath,path)payload:=map[string]interface{}{"data":data,}body,err:=json.Marshal(payload)iferr!=nil{returnerr}req,err:=http.NewRequestWithContext(ctx,http.MethodPost,url,strings.NewReader(string(body)))iferr!=nil{returnerr}req.Header.Set("X-Vault-Token",v.config.Token)req.Header.Set("Content-Type","application/json")ifv.config.Namespace!=""{req.Header.Set("X-Vault-Namespace",v.config.Namespace)}resp,err:=v.client.Do(req)iferr!=nil{returnfmt.Errorf("vaultwrite:%w",err)}deferresp.Body.Close()ifresp.StatusCode>=400{respBody,_:=io.ReadAll(resp.Body)returnfmt.Errorf("vaultwriteerror(%d):%s",resp.StatusCode,string(respBody))}returnnil}//InvalidateCacheclearsallcachedsecrets.func(v*VaultClient)InvalidateCache(){v.mu.Lock()deferv.mu.Unlock()v.cache=make(map[string]*cachedSecret)}//───T193:mTLSBetweenInternalServices───────────────────typeMTLSConfigstruct{Enabledbool`json:"enabled"`CertFilestring`json:"cert_file"`KeyFilestring`json:"key_file"`CAFilestring`json:"ca_file"`ServerNamestring`json:"server_name"`}//NewMTLSTransportcreatesanHTTPtransportwithmutualTLS.funcNewMTLSTransport(configMTLSConfig)(*http.Transport,error){if!config.Enabled{returnhttp.DefaultTransport.(*http.Transport).Clone(),nil}//Loadclientcertcert,err:=tls.LoadX509KeyPair(config.CertFile,config.KeyFile)iferr!=nil{returnnil,fmt.Errorf("loadclientcert:%w",err)}//LoadCAcertcaCert,err:=os.ReadFile(config.CAFile)iferr!=nil{returnnil,fmt.Errorf("loadCAcert:%w",err)}caCertPool:=x509.NewCertPool()if!caCertPool.AppendCertsFromPEM(caCert){returnnil,fmt.Errorf("failedtoappendCAcert")}tlsConfig:=&tls.Config{Certificates:[]tls.Certificate{cert},RootCAs:caCertPool,MinVersion:tls.VersionTLS13,}ifconfig.ServerName!=""{tlsConfig.ServerName=config.ServerName}return&http.Transport{TLSClientConfig:tlsConfig,},nil}//NewMTLSTLSConfigcreatesaTLSconfigforanHTTPSserverwithclientcertverification.funcNewMTLSTLSConfig(configMTLSConfig)(*tls.Config,error){if!config.Enabled{returnnil,nil}cert,err:=tls.LoadX509KeyPair(config.CertFile,config.KeyFile)iferr!=nil{returnnil,fmt.Errorf("loadservercert:%w",err)}caCert,err:=os.ReadFile(config.CAFile)iferr!=nil{returnnil,fmt.Errorf("loadCAcert:%w",err)}caCertPool:=x509.NewCertPool()if!caCertPool.AppendCertsFromPEM(caCert){returnnil,fmt.Errorf("failedtoappendCAcert")}return&tls.Config{Certificates:[]tls.Certificate{cert},ClientAuth:tls.RequireAndVerifyClientCert,ClientCAs:caCertPool,MinVersion:tls.VersionTLS13,},nil}//───T194:BYOKEncryption─────────────────────────────────typeBYOKConfigstruct{Enabledbool`json:"enabled"`MasterKeystring`json:"-"`//base64-encoded256-bitkeyKeySourcestring`json:"key_source"`//"env","vault","kms"}typeBYOKEncryptorstruct{configBYOKConfigmasterKey[]bytemusync.RWMutexdekCachemap[string][]byte//org_id->DEK}funcNewBYOKEncryptor(configBYOKConfig)(*BYOKEncryptor,error){e:=&BYOKEncryptor{config:config,dekCache:make(map[string][]byte),}ifconfig.Enabled&&config.MasterKey!=""{key,err:=base64.StdEncoding.DecodeString(config.MasterKey)iferr!=nil{returnnil,fmt.Errorf("decodemasterkey:%w",err)}iflen(key)!=32{returnnil,fmt.Errorf("masterkeymustbe256bits(32bytes),got%d",len(key))}e.masterKey=key}returne,nil}//GenerateDEKcreatesanewdataencryptionkeyforanorg,encryptedwiththemasterkey.func(e*BYOKEncryptor)GenerateDEK(orgIDstring)(encryptedDEKstring,errerror){//Generaterandom256-bitDEKdek:=make([]byte,32)if_,err:=rand.Read(dek);err!=nil{return"",fmt.Errorf("generateDEK:%w",err)}//EncryptDEKwithmasterkeyblock,err:=aes.NewCipher(e.masterKey)iferr!=nil{return"",fmt.Errorf("createcipher:%w",err)}gcm,err:=cipher.NewGCM(block)iferr!=nil{return"",fmt.Errorf("createGCM:%w",err)}nonce:=make([]byte,gcm.NonceSize())if_,err:=rand.Read(nonce);err!=nil{return"",fmt.Errorf("generatenonce:%w",err)}encDEK:=gcm.Seal(nonce,nonce,dek,[]byte(orgID))//CachetheplaintextDEKe.mu.Lock()e.dekCache[orgID]=deke.mu.Unlock()returnbase64.StdEncoding.EncodeToString(encDEK),nil}//Encryptencryptsdatausingtheorg'sDEK.func(e*BYOKEncryptor)Encrypt(orgIDstring,plaintext[]byte)(string,error){dek,err:=e.getDEK(orgID)iferr!=nil{return"",err}block,err:=aes.NewCipher(dek)iferr!=nil{return"",fmt.Errorf("createcipher:%w",err)}gcm,err:=cipher.NewGCM(block)iferr!=nil{return"",fmt.Errorf("createGCM:%w",err)}nonce:=make([]byte,gcm.NonceSize())if_,err:=rand.Read(nonce);err!=nil{return"",fmt.Errorf("generatenonce:%w",err)}ciphertext:=gcm.Seal(nonce,nonce,plaintext,nil)returnbase64.StdEncoding.EncodeToString(ciphertext),nil}//Decryptdecryptsdatausingtheorg'sDEK.func(e*BYOKEncryptor)Decrypt(orgIDstring,ciphertextB64string)([]byte,error){dek,err:=e.getDEK(orgID)iferr!=nil{returnnil,err}ciphertext,err:=base64.StdEncoding.DecodeString(ciphertextB64)iferr!=nil{returnnil,fmt.Errorf("decodeciphertext:%w",err)}block,err:=aes.NewCipher(dek)iferr!=nil{returnnil,fmt.Errorf("createcipher:%w",err)}gcm,err:=cipher.NewGCM(block)iferr!=nil{returnnil,fmt.Errorf("createGCM:%w",err)}nonceSize:=gcm.NonceSize()iflen(ciphertext)<nonceSize{returnnil,fmt.Errorf("ciphertexttooshort")}nonce,ciphertext:=ciphertext[:nonceSize],ciphertext[nonceSize:]returngcm.Open(nil,nonce,ciphertext,nil)}func(e*BYOKEncryptor)getDEK(orgIDstring)([]byte,error){e.mu.RLock()dek,ok:=e.dekCache[orgID]e.mu.RUnlock()ifok{returndek,nil}returnnil,fmt.Errorf("DEKnotfoundfororg%s—callGenerateDEKorLoadDEKfirst",orgID)}//LoadDEKdecryptsandcachesanorg'sDEKfromitsencryptedform.func(e*BYOKEncryptor)LoadDEK(orgID,encryptedDEKB64string)error{encDEK,err:=base64.StdEncoding.DecodeString(encryptedDEKB64)iferr!=nil{returnfmt.Errorf("decodeencryptedDEK:%w",err)}block,err:=aes.NewCipher(e.masterKey)iferr!=nil{returnfmt.Errorf("createcipher:%w",err)}gcm,err:=cipher.NewGCM(block)iferr!=nil{returnfmt.Errorf("createGCM:%w",err)}nonceSize:=gcm.NonceSize()iflen(encDEK)<nonceSize{returnfmt.Errorf("encryptedDEKtooshort")}nonce,ciphertext:=encDEK[:nonceSize],encDEK[nonceSize:]dek,err:=gcm.Open(nil,nonce,ciphertext,[]byte(orgID))iferr!=nil{returnfmt.Errorf("decryptDEK:%w",err)}e.mu.Lock()e.dekCache[orgID]=deke.mu.Unlock()returnnil}//───T195:DataResidencyRoutingEnforcement───────────────typeResidencyConfigstruct{OrgRegionsmap[string]string`json:"org_regions"`//org_id->regionProviderRegionsmap[string][]string`json:"provider_regions"`//provider->allowedregions}typeResidencyEnforcerstruct{musync.RWMutexconfigResidencyConfig}funcNewResidencyEnforcer(configResidencyConfig)*ResidencyEnforcer{return&ResidencyEnforcer{config:config}}//IsAllowedchecksifaprovidercanservearequestforthegivenorg.func(r*ResidencyEnforcer)IsAllowed(orgID,providerstring)(bool,string){r.mu.RLock()deferr.mu.RUnlock()orgRegion,ok:=r.config.OrgRegions[orgID]if!ok{returntrue,""//Norestriction}providerRegions,ok:=r.config.ProviderRegions[provider]if!ok{returnfalse,fmt.Sprintf("provider%shasnoregionconfig",provider)}for_,region:=rangeproviderRegions{ifregion==orgRegion||region=="global"{returntrue,""}}returnfalse,fmt.Sprintf("provider%snotavailableinorgregion%s",provider,orgRegion)}//FilterProvidersreturnsonlyprovidersallowedforthegivenorg'sregion.func(r*ResidencyEnforcer)FilterProviders(orgIDstring,providers[]string)[]string{r.mu.RLock()deferr.mu.RUnlock()orgRegion,ok:=r.config.OrgRegions[orgID]if!ok{returnproviders//Norestriction}varallowed[]stringfor_,p:=rangeproviders{regions:=r.config.ProviderRegions[p]for_,region:=rangeregions{ifregion==orgRegion||region=="global"{allowed=append(allowed,p)break}}}returnallowed}func(r*ResidencyEnforcer)SetOrgRegion(orgID,regionstring){r.mu.Lock()deferr.mu.Unlock()r.config.OrgRegions[orgID]=region}