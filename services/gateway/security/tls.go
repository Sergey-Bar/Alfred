packagesecurityimport("crypto/ecdsa""crypto/elliptic""crypto/rand""crypto/tls""crypto/x509""fmt""os""sync""sync/atomic""time")//───T220:TLS1.3Enforcement─────────────────────────────//TLSConfigholdstheconfigurationforgatewayTLStermination.typeTLSConfigstruct{Enabledbool`json:"enabled"`CertFilestring`json:"cert_file"`//PathtoPEMcertificateKeyFilestring`json:"key_file"`//PathtoPEMprivatekeyCAFilestring`json:"ca_file"`//Optional:CAbundleforclientverification//TLS1.3only—noTLS1.2fallbackMinVersionuint16`json:"min_version"`//Certificateauto-reloadinterval(forcert-managerrotation)ReloadIntervaltime.Duration`json:"reload_interval"`//SessionticketrotationintervalSessionTicketRotationtime.Duration`json:"session_ticket_rotation"`//OCSPstaplingOCSPStaplingbool`json:"ocsp_stapling"`//ClientcertificateverificationmodeClientAuthtls.ClientAuthType`json:"client_auth"`}//DefaultTLSConfigreturnsahardenedTLS1.3configuration.funcDefaultTLSConfig()TLSConfig{returnTLSConfig{Enabled:false,MinVersion:tls.VersionTLS13,ReloadInterval:5*time.Minute,SessionTicketRotation:6*time.Hour,OCSPStapling:true,ClientAuth:tls.NoClientCert,}}//TLSManagermanagesTLScertificatelifecycleforthegateway.typeTLSManagerstruct{configTLSConfigmusync.RWMutexcertatomic.Pointer[tls.Certificate]stopChchanstruct{}certExpirytime.Time//Sessionticketkeys—rotatedperiodicallyticketKeys[3][32]byte//current+2previousticketKeysMusync.RWMutexticketVersionint}//NewTLSManagercreatesanewTLSmanager.funcNewTLSManager(configTLSConfig)(*TLSManager,error){if!config.Enabled{return&TLSManager{config:config,stopCh:make(chanstruct{})},nil}ifconfig.MinVersion==0{config.MinVersion=tls.VersionTLS13}//SECURITY:RejectanyattempttolowerbelowTLS1.3ifconfig.MinVersion<tls.VersionTLS13{returnnil,fmt.Errorf("TLSversion%#xisbelowminimumallowed(TLS1.3=%#x)",config.MinVersion,tls.VersionTLS13)}m:=&TLSManager{config:config,stopCh:make(chanstruct{}),}//Loadinitialcertificateiferr:=m.loadCertificate();err!=nil{returnnil,fmt.Errorf("loadinitialcertificate:%w",err)}//Generateinitialsessionticketkeysm.rotateSessionTickets()returnm,nil}//TLSConfigForServerreturnsa*tls.Configsuitablefornet/http.Server.func(m*TLSManager)TLSConfigForServer()*tls.Config{tlsCfg:=&tls.Config{//───TLS1.3ONLY—nofallback───MinVersion:tls.VersionTLS13,MaxVersion:tls.VersionTLS13,//TLS1.3ciphersuites(GomanagestheseautomaticallyforTLS1.3,//butweexplicitlysetCurvePreferencesforkeyexchange)CurvePreferences:[]tls.CurveID{tls.X25519,//fastest,mostsecuretls.CurveP256,//NISTfallback},//Dynamiccertificateretrieval—supportshot-reloadGetCertificate:m.getCertificate,//Sessionticketkeys—rotatedperiodicallySessionTicketsDisabled:false,//RenegotiationisnotrelevantforTLS1.3butexplicitlydisabledRenegotiation:tls.RenegotiateNever,//ClientauthmodeClientAuth:m.config.ClientAuth,}//ConfigureclientCApoolformTLSifm.config.CAFile!=""&&m.config.ClientAuth>tls.NoClientCert{caCert,err:=os.ReadFile(m.config.CAFile)iferr==nil{pool:=x509.NewCertPool()ifpool.AppendCertsFromPEM(caCert){tlsCfg.ClientCAs=pool}}}returntlsCfg}//getCertificateisthetls.Configcallbackfordynamiccertretrieval.func(m*TLSManager)getCertificate(hello*tls.ClientHelloInfo)(*tls.Certificate,error){cert:=m.cert.Load()ifcert==nil{returnnil,fmt.Errorf("noTLScertificateloaded")}returncert,nil}//loadCertificatereadsandparsesthecertificatefromdisk.func(m*TLSManager)loadCertificate()error{cert,err:=tls.LoadX509KeyPair(m.config.CertFile,m.config.KeyFile)iferr!=nil{returnfmt.Errorf("loadkeypair%s/%s:%w",m.config.CertFile,m.config.KeyFile,err)}//Parsetheleafcerttoextractexpiryifcert.Leaf==nil&&len(cert.Certificate)>0{leaf,err:=x509.ParseCertificate(cert.Certificate[0])iferr==nil{cert.Leaf=leaf}}m.cert.Store(&cert)//Updatetrackedexpiryifcert.Leaf!=nil{m.mu.Lock()m.certExpiry=cert.Leaf.NotAfterm.mu.Unlock()}returnnil}//rotateSessionTicketsgeneratesanewsessionticketkeyandshiftsoldkeys.func(m*TLSManager)rotateSessionTickets(){m.ticketKeysMu.Lock()deferm.ticketKeysMu.Unlock()//Shift:[0]→[1]→[2](dropoldest)m.ticketKeys[2]=m.ticketKeys[1]m.ticketKeys[1]=m.ticketKeys[0]//GeneratenewkeyvarnewKey[32]byteif_,err:=rand.Read(newKey[:]);err!=nil{//Fallback:useECDSAkeygenerationasentropysourcekey,_:=ecdsa.GenerateKey(elliptic.P256(),rand.Reader)copy(newKey[:],key.D.Bytes())}m.ticketKeys[0]=newKeym.ticketVersion++}//Startbeginsbackgroundcertificatereloadandsessionticketrotation.func(m*TLSManager)Start(){if!m.config.Enabled{return}//Certificatehot-reloadloopgofunc(){ticker:=time.NewTicker(m.config.ReloadInterval)deferticker.Stop()for{select{case<-ticker.C:iferr:=m.loadCertificate();err!=nil{//Logbutdon'tcrash—keepservingwithexistingcert_=err}case<-m.stopCh:return}}}()//Sessionticketkeyrotationloopgofunc(){ticker:=time.NewTicker(m.config.SessionTicketRotation)deferticker.Stop()for{select{case<-ticker.C:m.rotateSessionTickets()case<-m.stopCh:return}}}()}//Stophaltsbackgroundgoroutines.func(m*TLSManager)Stop(){close(m.stopCh)}//CertExpiryreturnsthecurrentcertificate'sexpirationtime.func(m*TLSManager)CertExpiry()time.Time{m.mu.RLock()deferm.mu.RUnlock()returnm.certExpiry}//CertExpiresInreturnsthedurationuntilthecurrentcertificateexpires.func(m*TLSManager)CertExpiresIn()time.Duration{m.mu.RLock()deferm.mu.RUnlock()returntime.Until(m.certExpiry)}//HealthCheckreturnsanerrorifthecertificateisexpiredorabouttoexpire.func(m*TLSManager)HealthCheck()error{if!m.config.Enabled{returnnil//TLSnotenabled,nocerttocheck}expiresIn:=m.CertExpiresIn()ifexpiresIn<=0{returnfmt.Errorf("TLScertificateEXPIRED%sago",-expiresIn)}ifexpiresIn<7*24*time.Hour{returnfmt.Errorf("TLScertificateexpiresin%s(<7days)",expiresIn.Round(time.Hour))}returnnil}//TLSVersionStringconvertsaTLSversionconstanttoahuman-readablestring.funcTLSVersionString(versionuint16)string{switchversion{casetls.VersionTLS10:return"TLS1.0"casetls.VersionTLS11:return"TLS1.1"casetls.VersionTLS12:return"TLS1.2"casetls.VersionTLS13:return"TLS1.3"default:returnfmt.Sprintf("Unknown(%#x)",version)}}//───TLSConnectionValidator───────────────────────────────//ValidateTLSConnectionchecksthatanincomingTLSconnectionmeets//Alfred'ssecurityrequirements.funcValidateTLSConnection(state*tls.ConnectionState)error{ifstate==nil{returnfmt.Errorf("connectionisnotTLS")}//EnforceTLS1.3ifstate.Version<tls.VersionTLS13{returnfmt.Errorf("TLSversion%sisbelowminimumTLS1.3",TLSVersionString(state.Version))}returnnil}