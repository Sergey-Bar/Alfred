packageanalyticsimport("context""encoding/json""fmt""sync""sync/atomic""time""github.com/rs/zerolog")//───EventTypes────────────────────────────────────────────//EventTypeclassifiesanalyticsevents.typeEventTypestringconst(EventTypeRequestEventType="request"EventTypeCostEventType="cost"EventTypeWalletEventType="wallet")//RequestEventcapturesanLLMrequestprocessedbythegateway.typeRequestEventstruct{RequestIDstring`json:"request_id"`TraceIDstring`json:"trace_id"`OrgIDstring`json:"org_id"`TeamIDstring`json:"team_id"`UserIDstring`json:"user_id"`APIKeyHashstring`json:"api_key_hash"`Modelstring`json:"model"`Providerstring`json:"provider"`Endpointstring`json:"endpoint"`Methodstring`json:"method"`PromptTokensint`json:"prompt_tokens"`CompletionTokensint`json:"completion_tokens"`TotalTokensint`json:"total_tokens"`CostMicrodollarsint64`json:"cost_microdollars"`LatencyMsint`json:"latency_ms"`TTFBMsint`json:"ttfb_ms"`ProviderLatencyMsint`json:"provider_latency_ms"`StatusCodeint`json:"status_code"`ErrorTypestring`json:"error_type"`IsCachedbool`json:"is_cached"`CacheSimilarityfloat32`json:"cache_similarity"`RoutingRuleIDstring`json:"routing_rule_id"`WasFailoverbool`json:"was_failover"`SafetyBlockedbool`json:"safety_blocked"`SafetyViolationsint`json:"safety_violations"`CreatedAttime.Time`json:"created_at"`}//CostEventcapturesacredit/costmutation.typeCostEventstruct{EventIDstring`json:"event_id"`OrgIDstring`json:"org_id"`TeamIDstring`json:"team_id"`UserIDstring`json:"user_id"`WalletIDstring`json:"wallet_id"`Modelstring`json:"model"`Providerstring`json:"provider"`PromptTokensint`json:"prompt_tokens"`CompletionTokensint`json:"completion_tokens"`CostMicrodollarsint64`json:"cost_microdollars"`BalanceBeforeint64`json:"balance_before"`BalanceAfterint64`json:"balance_after"`WalletTypestring`json:"wallet_type"`RequestIDstring`json:"request_id"`EventTypestring`json:"event_type"`//deduction,refund,topup,transferDescriptionstring`json:"description"`CreatedAttime.Time`json:"created_at"`}//WalletEventcaptureswalletlifecyclechanges.typeWalletEventstruct{EventIDstring`json:"event_id"`WalletIDstring`json:"wallet_id"`OrgIDstring`json:"org_id"`TeamIDstring`json:"team_id"`UserIDstring`json:"user_id"`EventTypestring`json:"event_type"`OldValuestring`json:"old_value"`NewValuestring`json:"new_value"`ActorIDstring`json:"actor_id"`ActorTypestring`json:"actor_type"`CreatedAttime.Time`json:"created_at"`}//───SinkInterface─────────────────────────────────────────//Sinkisthedestinationforanalyticsevents(ClickHouse,stdout,etc.).typeSinkinterface{//WriteRequestsinsertsabatchofrequestevents.WriteRequests(ctxcontext.Context,events[]RequestEvent)error//WriteCostsinsertsabatchofcostevents.WriteCosts(ctxcontext.Context,events[]CostEvent)error//WriteWalletEventsinsertsabatchofwalletevents.WriteWalletEvents(ctxcontext.Context,events[]WalletEvent)error//Closereleasesresources.Close()error}//───PipelineConfiguration─────────────────────────────────//PipelineConfigcontrolsbatchingandbackpressurebehavior.typePipelineConfigstruct{//BufferSizeisthechannelbuffersizepereventtype.BufferSizeint`json:"buffer_size"`//BatchSizeisthemaxeventsperflush.BatchSizeint`json:"batch_size"`//FlushIntervalisthemaxtimebetweenflushes.FlushIntervaltime.Duration`json:"flush_interval"`//MaxRetriesforfailedflushes.MaxRetriesint`json:"max_retries"`//RetryDelaybasedelay(exponentialbackoff).RetryDelaytime.Duration`json:"retry_delay"`//Workersisthenumberofconcurrentflushworkerspertype.Workersint`json:"workers"`}//DefaultPipelineConfigreturnsproductiondefaults.funcDefaultPipelineConfig()PipelineConfig{returnPipelineConfig{BufferSize:100000,BatchSize:1000,FlushInterval:5*time.Second,MaxRetries:3,RetryDelay:500*time.Millisecond,Workers:2,}}//───Pipeline───────────────────────────────────────────────//Pipelineistheasyncanalyticsingestionengine.typePipelinestruct{loggerzerolog.LoggerconfigPipelineConfigsinkSinkrequestChchanRequestEventcostChchanCostEventwalletChchanWalletEventwgsync.WaitGroupcancelcontext.CancelFunc//MetricseventsReceivedint64eventsWrittenint64eventsDroppedint64flushErrorsint64musync.RWMutex//In-memoryeventhistoryforqueries(recenteventsonly)//Model:ClaudeOpus4//Tier:L3//Logic:Ringbufferforrecenteventstosupportanalyticsqueries//RootCause:BUG-003-Analyticshandlersreturnedemptydata//Context:KeepslastNeventsfordevelopment/fallbackqueries//Suitability:L3-concurrency-safein-memorydatastructurerecentRequests[]RequestEventrecentCosts[]CostEventrequestsMusync.RWMutexcostsMusync.RWMutexmaxRecentSizeint}//NewPipelinecreatesanewanalyticsingestionpipeline.funcNewPipeline(loggerzerolog.Logger,sinkSink,config...PipelineConfig)*Pipeline{cfg:=DefaultPipelineConfig()iflen(config)>0{cfg=config[0]}return&Pipeline{logger:logger.With().Str("component","analytics-pipeline").Logger(),config:cfg,sink:sink,requestCh:make(chanRequestEvent,cfg.BufferSize),costCh:make(chanCostEvent,cfg.BufferSize),walletCh:make(chanWalletEvent,cfg.BufferSize),recentRequests:make([]RequestEvent,0,10000),recentCosts:make([]CostEvent,0,10000),maxRecentSize:10000,}}//Startlaunchesthepipelineworkers.func(p*Pipeline)Start(ctxcontext.Context){ctx,p.cancel=context.WithCancel(ctx)//Startrequesteventworkersfori:=0;i<p.config.Workers;i++{p.wg.Add(1)gop.requestWorker(ctx,i)}//Startcosteventworkersfori:=0;i<p.config.Workers;i++{p.wg.Add(1)gop.costWorker(ctx,i)}//Startwalleteventworkersfori:=0;i<p.config.Workers;i++{p.wg.Add(1)gop.walletWorker(ctx,i)}p.logger.Info().Int("workers_per_type",p.config.Workers).Int("buffer_size",p.config.BufferSize).Int("batch_size",p.config.BatchSize).Dur("flush_interval",p.config.FlushInterval).Msg("analyticspipelinestarted")}//Stopgracefullyshutsdownthepipeline,flushingremainingevents.func(p*Pipeline)Stop(){ifp.cancel!=nil{p.cancel()}p.wg.Wait()//Finaldrainp.drainRequests()p.drainCosts()p.drainWalletEvents()ifp.sink!=nil{_=p.sink.Close()}p.logger.Info().Int64("received",p.eventsReceived).Int64("written",p.eventsWritten).Int64("dropped",p.eventsDropped).Int64("flush_errors",p.flushErrors).Msg("analyticspipelinestopped")}//───IngestMethods(non-blocking)─────────────────────────//TrackRequestsubmitsarequesteventtothepipeline.//Non-blocking:dropseventifbufferisfull.func(p*Pipeline)TrackRequest(eventRequestEvent){ifevent.CreatedAt.IsZero(){event.CreatedAt=time.Now().UTC()}//Storeinrecenthistoryforqueriesp.requestsMu.Lock()iflen(p.recentRequests)>=p.maxRecentSize{//Removeoldest10%p.recentRequests=p.recentRequests[p.maxRecentSize/10:]}p.recentRequests=append(p.recentRequests,event)p.requestsMu.Unlock()select{casep.requestCh<-event:p.incReceived()default:p.incDropped()p.logger.Warn().Str("request_id",event.RequestID).Msg("requesteventdropped:bufferfull")}}//TrackCostsubmitsacosteventtothepipeline.func(p*Pipeline)TrackCost(eventCostEvent){ifevent.CreatedAt.IsZero(){event.CreatedAt=time.Now().UTC()}//Storeinrecenthistoryforqueriesp.costsMu.Lock()iflen(p.recentCosts)>=p.maxRecentSize{//Removeoldest10%p.recentCosts=p.recentCosts[p.maxRecentSize/10:]}p.recentCosts=append(p.recentCosts,event)p.costsMu.Unlock()select{casep.costCh<-event:p.incReceived()default:p.incDropped()p.logger.Warn().Str("event_id",event.EventID).Msg("costeventdropped:bufferfull")}}//TrackWalletEventsubmitsawalletlifecycleeventtothepipeline.func(p*Pipeline)TrackWalletEvent(eventWalletEvent){ifevent.CreatedAt.IsZero(){event.CreatedAt=time.Now().UTC()}select{casep.walletCh<-event:p.incReceived()default:p.incDropped()p.logger.Warn().Str("event_id",event.EventID).Msg("walleteventdropped:bufferfull")}}//───Workers────────────────────────────────────────────────func(p*Pipeline)requestWorker(ctxcontext.Context,idint){deferp.wg.Done()ticker:=time.NewTicker(p.config.FlushInterval)deferticker.Stop()batch:=make([]RequestEvent,0,p.config.BatchSize)for{select{case<-ctx.Done()://Flushremainingiflen(batch)>0{p.flushRequests(batch)}returncaseevent:=<-p.requestCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushRequests(batch)batch=batch[:0]}case<-ticker.C:iflen(batch)>0{p.flushRequests(batch)batch=batch[:0]}}}}func(p*Pipeline)costWorker(ctxcontext.Context,idint){deferp.wg.Done()ticker:=time.NewTicker(p.config.FlushInterval)deferticker.Stop()batch:=make([]CostEvent,0,p.config.BatchSize)for{select{case<-ctx.Done():iflen(batch)>0{p.flushCosts(batch)}returncaseevent:=<-p.costCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushCosts(batch)batch=batch[:0]}case<-ticker.C:iflen(batch)>0{p.flushCosts(batch)batch=batch[:0]}}}}func(p*Pipeline)walletWorker(ctxcontext.Context,idint){deferp.wg.Done()ticker:=time.NewTicker(p.config.FlushInterval)deferticker.Stop()batch:=make([]WalletEvent,0,p.config.BatchSize)for{select{case<-ctx.Done():iflen(batch)>0{p.flushWalletEvents(batch)}returncaseevent:=<-p.walletCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushWalletEvents(batch)batch=batch[:0]}case<-ticker.C:iflen(batch)>0{p.flushWalletEvents(batch)batch=batch[:0]}}}}//───FlushwithRetry───────────────────────────────────────func(p*Pipeline)flushRequests(batch[]RequestEvent){ctx,cancel:=context.WithTimeout(context.Background(),30*time.Second)defercancel()varerrerrorforattempt:=0;attempt<=p.config.MaxRetries;attempt++{err=p.sink.WriteRequests(ctx,batch)iferr==nil{p.incWritten(int64(len(batch)))return}p.logger.Warn().Err(err).Int("attempt",attempt+1).Int("batch_size",len(batch)).Msg("requestflushfailed")ifattempt<p.config.MaxRetries{time.Sleep(p.config.RetryDelay*time.Duration(1<<uint(attempt)))}}p.incFlushErrors()p.incDropped()p.logger.Error().Err(err).Int("batch_size",len(batch)).Msg("requestbatchdroppedafterretries")}func(p*Pipeline)flushCosts(batch[]CostEvent){ctx,cancel:=context.WithTimeout(context.Background(),30*time.Second)defercancel()varerrerrorforattempt:=0;attempt<=p.config.MaxRetries;attempt++{err=p.sink.WriteCosts(ctx,batch)iferr==nil{p.incWritten(int64(len(batch)))return}p.logger.Warn().Err(err).Int("attempt",attempt+1).Msg("costflushfailed")ifattempt<p.config.MaxRetries{time.Sleep(p.config.RetryDelay*time.Duration(1<<uint(attempt)))}}p.incFlushErrors()p.incDropped()p.logger.Error().Err(err).Int("batch_size",len(batch)).Msg("costbatchdroppedafterretries")}func(p*Pipeline)flushWalletEvents(batch[]WalletEvent){ctx,cancel:=context.WithTimeout(context.Background(),30*time.Second)defercancel()varerrerrorforattempt:=0;attempt<=p.config.MaxRetries;attempt++{err=p.sink.WriteWalletEvents(ctx,batch)iferr==nil{p.incWritten(int64(len(batch)))return}p.logger.Warn().Err(err).Int("attempt",attempt+1).Msg("walleteventflushfailed")ifattempt<p.config.MaxRetries{time.Sleep(p.config.RetryDelay*time.Duration(1<<uint(attempt)))}}p.incFlushErrors()p.incDropped()p.logger.Error().Err(err).Int("batch_size",len(batch)).Msg("walleteventbatchdroppedafterretries")}//───Drain(shutdown)───────────────────────────────────────func(p*Pipeline)drainRequests(){batch:=make([]RequestEvent,0,p.config.BatchSize)for{select{caseevent:=<-p.requestCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushRequests(batch)batch=batch[:0]}default:iflen(batch)>0{p.flushRequests(batch)}return}}}func(p*Pipeline)drainCosts(){batch:=make([]CostEvent,0,p.config.BatchSize)for{select{caseevent:=<-p.costCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushCosts(batch)batch=batch[:0]}default:iflen(batch)>0{p.flushCosts(batch)}return}}}func(p*Pipeline)drainWalletEvents(){batch:=make([]WalletEvent,0,p.config.BatchSize)for{select{caseevent:=<-p.walletCh:batch=append(batch,event)iflen(batch)>=p.config.BatchSize{p.flushWalletEvents(batch)batch=batch[:0]}default:iflen(batch)>0{p.flushWalletEvents(batch)}return}}}//───Metrics────────────────────────────────────────────────func(p*Pipeline)incReceived(){atomic.AddInt64(&p.eventsReceived,1)}func(p*Pipeline)incWritten(nint64){atomic.AddInt64(&p.eventsWritten,n)}func(p*Pipeline)incDropped(){atomic.AddInt64(&p.eventsDropped,1)}func(p*Pipeline)incDroppedN(nint64){atomic.AddInt64(&p.eventsDropped,n)}func(p*Pipeline)incFlushErrors(){atomic.AddInt64(&p.flushErrors,1)}//Statsreturnspipelinestatistics.typePipelineStatsstruct{EventsReceivedint64`json:"events_received"`EventsWrittenint64`json:"events_written"`EventsDroppedint64`json:"events_dropped"`FlushErrorsint64`json:"flush_errors"`RequestBufferint`json:"request_buffer_len"`CostBufferint`json:"cost_buffer_len"`WalletBufferint`json:"wallet_buffer_len"`}func(p*Pipeline)Stats()PipelineStats{returnPipelineStats{EventsReceived:atomic.LoadInt64(&p.eventsReceived),EventsWritten:atomic.LoadInt64(&p.eventsWritten),EventsDropped:atomic.LoadInt64(&p.eventsDropped),FlushErrors:atomic.LoadInt64(&p.flushErrors),RequestBuffer:len(p.requestCh),CostBuffer:len(p.costCh),WalletBuffer:len(p.walletCh),}}//───QueryMethods(foranalyticshandlers)─────────────────//QueryRequestsreturnsrecentrequesteventsmatchingthedaterange.//Model:ClaudeOpus4//Tier:L3//Logic:Filterin-memoryrequesthistorybydaterange//RootCause:BUG-003-Analyticshandlersreturnedemptydata//Context:ProvidesfallbackquerywhenClickHouseisn'tavailable//Suitability:L3-dataaggregationlogicfunc(p*Pipeline)QueryRequests(startDate,endDatetime.Time)[]RequestEvent{p.requestsMu.RLock()deferp.requestsMu.RUnlock()varresult[]RequestEventfor_,event:=rangep.recentRequests{if(event.CreatedAt.Equal(startDate)||event.CreatedAt.After(startDate))&&(event.CreatedAt.Equal(endDate)||event.CreatedAt.Before(endDate)){result=append(result,event)}}returnresult}//QueryCostsreturnsrecentcosteventsmatchingthedaterange.func(p*Pipeline)QueryCosts(startDate,endDatetime.Time)[]CostEvent{p.costsMu.RLock()deferp.costsMu.RUnlock()varresult[]CostEventfor_,event:=rangep.recentCosts{if(event.CreatedAt.Equal(startDate)||event.CreatedAt.After(startDate))&&(event.CreatedAt.Equal(endDate)||event.CreatedAt.Before(endDate)){result=append(result,event)}}returnresult}//AggregatedCostrepresentsaggregatedcostdata.typeAggregatedCoststruct{Datestring`json:"date"`Providerstring`json:"provider,omitempty"`Modelstring`json:"model,omitempty"`TeamIDstring`json:"team_id,omitempty"`RequestCountint64`json:"request_count"`PromptTokensint64`json:"prompt_tokens"`CompletionTokensint64`json:"completion_tokens"`TotalTokensint64`json:"total_tokens"`CostMicrodollarsint64`json:"cost_microdollars"`CostUSDfloat64`json:"cost_usd"`CacheHitsint64`json:"cache_hits"`}//AggregateDailyaggregatesrequesteventsbydate.func(p*Pipeline)AggregateDaily(startDate,endDatetime.Time,groupBystring)[]AggregatedCost{events:=p.QueryRequests(startDate,endDate)//Groupbydate(andoptionallyprovider/model/team)typeaggKeystruct{DatestringProviderstringModelstringTeamIDstring}aggregates:=make(map[aggKey]*AggregatedCost)for_,event:=rangeevents{dateStr:=event.CreatedAt.Format("2006-01-02")key:=aggKey{Date:dateStr}switchgroupBy{case"provider":key.Provider=event.Providercase"model":key.Model=event.Modelcase"team":key.TeamID=event.TeamID}if_,exists:=aggregates[key];!exists{aggregates[key]=&AggregatedCost{Date:dateStr,Provider:key.Provider,Model:key.Model,TeamID:key.TeamID,}}agg:=aggregates[key]agg.RequestCount++agg.PromptTokens+=int64(event.PromptTokens)agg.CompletionTokens+=int64(event.CompletionTokens)agg.TotalTokens+=int64(event.TotalTokens)agg.CostMicrodollars+=event.CostMicrodollarsagg.CostUSD=float64(agg.CostMicrodollars)/1_000_000ifevent.IsCached{agg.CacheHits++}}//Converttosliceresult:=make([]AggregatedCost,0,len(aggregates))for_,agg:=rangeaggregates{result=append(result,*agg)}returnresult}//CacheStatsreturnscachehitstatistics.func(p*Pipeline)CacheStats(startDate,endDatetime.Time)(hitRatefloat64,totalHits,totalRequestsint64){events:=p.QueryRequests(startDate,endDate)for_,event:=rangeevents{totalRequests++ifevent.IsCached{totalHits++}}iftotalRequests>0{hitRate=float64(totalHits)/float64(totalRequests)*100}returnhitRate,totalHits,totalRequests}//───LogSink(fallbackwhenClickHouseisunavailable)─────//LogSinkwriteseventsasstructuredJSONlogs(development/fallback).typeLogSinkstruct{loggerzerolog.Logger}//NewLogSinkcreatesasinkthatlogseventsasstructuredJSON.funcNewLogSink(loggerzerolog.Logger)*LogSink{return&LogSink{logger:logger.With().Str("sink","log").Logger()}}func(s*LogSink)WriteRequests(_context.Context,events[]RequestEvent)error{for_,e:=rangeevents{data,_:=json.Marshal(e)s.logger.Debug().RawJSON("event",data).Msg("request_event")}returnnil}func(s*LogSink)WriteCosts(_context.Context,events[]CostEvent)error{for_,e:=rangeevents{data,_:=json.Marshal(e)s.logger.Debug().RawJSON("event",data).Msg("cost_event")}returnnil}func(s*LogSink)WriteWalletEvents(_context.Context,events[]WalletEvent)error{for_,e:=rangeevents{data,_:=json.Marshal(e)s.logger.Debug().RawJSON("event",data).Msg("wallet_event")}returnnil}func(s*LogSink)Close()error{returnnil}//───ClickHouseSink(production)───────────────────────────//ClickHouseSinkwriteseventstoClickHouseviathenativeprotocol.//Requires:github.com/ClickHouse/clickhouse-go/v2typeClickHouseSinkstruct{dsnstringloggerzerolog.Logger//connwouldholdtheClickHouseconnectioninproduction.//Fornow,thisisastructuralplaceholderthatlogswarnings.}//NewClickHouseSinkcreatesaproductionClickHousesink.funcNewClickHouseSink(dsnstring,loggerzerolog.Logger)(*ClickHouseSink,error){ifdsn==""{returnnil,fmt.Errorf("clickhouseDSNisrequired")}return&ClickHouseSink{dsn:dsn,logger:logger.With().Str("sink","clickhouse").Logger(),},nil}func(s*ClickHouseSink)WriteRequests(ctxcontext.Context,events[]RequestEvent)error{//TODO:Implementbatchinsertusingclickhouse-go/v2//batch,err:=conn.PrepareBatch(ctx,"INSERTINTOrequest_log(...)")s.logger.Warn().Int("count",len(events)).Msg("clickhousesink:requestwritenotyetwiredtodriver")returnnil}func(s*ClickHouseSink)WriteCosts(ctxcontext.Context,events[]CostEvent)error{s.logger.Warn().Int("count",len(events)).Msg("clickhousesink:costwritenotyetwiredtodriver")returnnil}func(s*ClickHouseSink)WriteWalletEvents(ctxcontext.Context,events[]WalletEvent)error{s.logger.Warn().Int("count",len(events)).Msg("clickhousesink:walletwritenotyetwiredtodriver")returnnil}func(s*ClickHouseSink)Close()error{returnnil}