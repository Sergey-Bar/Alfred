packageproviderimport("context""encoding/json""fmt""io""net/http""sync""time""github.com/rs/zerolog")//ModelSyncerperiodicallyfetchesavailablemodelsfromproviders.typeModelSyncerstruct{registry*Registrylogzerolog.Loggerintervaltime.Durationcatalogmap[string][]ModelInfo//provider->modelsmusync.RWMutexstopChchanstruct{}client*http.Client}//ModelInforepresentsamodelavailableonaprovider.typeModelInfostruct{IDstring`json:"id"`Objectstring`json:"object,omitempty"`OwnedBystring`json:"owned_by,omitempty"`Providerstring`json:"provider"`SyncedAttime.Time`json:"synced_at"`}//NewModelSyncercreatesanewmodelsyncer.funcNewModelSyncer(registry*Registry,logzerolog.Logger,intervaltime.Duration)*ModelSyncer{ifinterval==0{interval=5*time.Minute}return&ModelSyncer{registry:registry,log:log.With().Str("component","model_syncer").Logger(),interval:interval,catalog:make(map[string][]ModelInfo),stopCh:make(chanstruct{}),client:&http.Client{Timeout:15*time.Second,},}}//Startbeginsthebackgroundmodelsyncloop.func(s*ModelSyncer)Start(){gos.loop()s.log.Info().Dur("interval",s.interval).Msg("modelsyncerstarted")}//Stophaltsthebackgroundsyncloop.func(s*ModelSyncer)Stop(){close(s.stopCh)s.log.Info().Msg("modelsyncerstopped")}//GetCatalogreturnsthecurrentmodelcatalogacrossallproviders.func(s*ModelSyncer)GetCatalog()map[string][]ModelInfo{s.mu.RLock()defers.mu.RUnlock()//Deepcopyresult:=make(map[string][]ModelInfo,len(s.catalog))fork,v:=ranges.catalog{models:=make([]ModelInfo,len(v))copy(models,v)result[k]=models}returnresult}//GetAllModelsreturnsaflatlistofallmodelsacrossallproviders.func(s*ModelSyncer)GetAllModels()[]ModelInfo{s.mu.RLock()defers.mu.RUnlock()varall[]ModelInfofor_,models:=ranges.catalog{all=append(all,models...)}returnall}func(s*ModelSyncer)loop(){//Syncimmediatelyonstarts.syncAll()ticker:=time.NewTicker(s.interval)deferticker.Stop()for{select{case<-s.stopCh:returncase<-ticker.C:s.syncAll()}}}func(s*ModelSyncer)syncAll(){providers:=s.registry.List()s.log.Debug().Int("providers",len(providers)).Msg("syncingmodellists")varwgsync.WaitGroupresults:=make(map[string][]ModelInfo)varmusync.Mutexfor_,name:=rangeproviders{prov,ok:=s.registry.Get(name)if!ok{continue}wg.Add(1)gofunc(nstring,pProvider){deferwg.Done()models:=p.Models()now:=time.Now()infos:=make([]ModelInfo,len(models))fori,m:=rangemodels{infos[i]=ModelInfo{ID:m,Provider:n,SyncedAt:now,}}mu.Lock()results[n]=infosmu.Unlock()s.log.Debug().Str("provider",n).Int("models",len(models)).Msg("syncedmodels")}(name,prov)}wg.Wait()s.mu.Lock()s.catalog=resultss.mu.Unlock()total:=0for_,v:=rangeresults{total+=len(v)}s.log.Info().Int("providers",len(results)).Int("total_models",total).Msg("modelsynccomplete")}//───OpenAI-compatible/v1/modelsAPIresponse──────────────//ModelsListResponseistheresponseforGET/v1/models.typeModelsListResponsestruct{Objectstring`json:"object"`Data[]ModelInfo`json:"data"`}//FetchRemoteModelstriestofetchthe/v1/modelslistfromaprovider's//baseURL.Fallsbacktothestaticmodellistonfailure.funcFetchRemoteModels(ctxcontext.Context,baseURL,apiKeystring)([]string,error){client:=&http.Client{Timeout:10*time.Second}req,err:=http.NewRequestWithContext(ctx,http.MethodGet,baseURL+"/v1/models",nil)iferr!=nil{returnnil,fmt.Errorf("createrequest:%w",err)}ifapiKey!=""{req.Header.Set("Authorization","Bearer"+apiKey)}resp,err:=client.Do(req)iferr!=nil{returnnil,fmt.Errorf("fetchmodels:%w",err)}deferresp.Body.Close()ifresp.StatusCode!=http.StatusOK{body,_:=io.ReadAll(resp.Body)returnnil,fmt.Errorf("status%d:%s",resp.StatusCode,string(body))}varlistRespstruct{Data[]struct{IDstring`json:"id"`}`json:"data"`}iferr:=json.NewDecoder(resp.Body).Decode(&listResp);err!=nil{returnnil,fmt.Errorf("decodemodels:%w",err)}models:=make([]string,len(listResp.Data))fori,m:=rangelistResp.Data{models[i]=m.ID}returnmodels,nil}