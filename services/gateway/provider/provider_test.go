packageproviderimport("context""io""net/http""strings""testing""time")//TestRegistryteststheproviderregistryoperationsfuncTestRegistry(t*testing.T){t.Run("NewRegistrycreatesemptyregistry",func(t*testing.T){reg:=NewRegistry()ifreg==nil{t.Fatal("NewRegistryreturnednil")}ifreg.providers==nil{t.Error("Registryprovidersmapisnil")}})t.Run("RegisterandGetprovider",func(t*testing.T){reg:=NewRegistry()mock:=&MockProvider{name:"test"}reg.Register(mock)got,ok:=reg.Get("test")if!ok{t.Error("Get()returnednotfound")}ifgot!=mock{t.Errorf("Get()returnedwrongprovider")}})t.Run("Getnon-existentproviderreturnsnil",func(t*testing.T){reg:=NewRegistry()got,ok:=reg.Get("nonexistent")ifok{t.Errorf("Get()shouldreturnfalsefornon-existentprovider")}ifgot!=nil{t.Errorf("Get()shouldreturnnilfornon-existentprovider")}})t.Run("Listproviders",func(t*testing.T){reg:=NewRegistry()reg.Register(&MockProvider{name:"provider1"})reg.Register(&MockProvider{name:"provider2"})names:=reg.List()iflen(names)!=2{t.Errorf("List()returned%dproviders,want2",len(names))}//Checkbothprovidersareinthelistfound:=make(map[string]bool)for_,name:=rangenames{found[name]=true}if!found["provider1"]||!found["provider2"]{t.Errorf("List()missingexpectedproviders:got%v",names)}})t.Run("Concurrentaccesstoregistry",func(t*testing.T){reg:=NewRegistry()//Simulateconcurrentregistrationandretrievaldone:=make(chanbool)//Goroutine1:Registerprovidersgofunc(){fori:=0;i<10;i++{reg.Register(&MockProvider{name:string(rune('a'+i))})}done<-true}()//Goroutine2:Getprovidersgofunc(){fori:=0;i<10;i++{reg.Get("a")}done<-true}()//Waitforbothgoroutines<-done<-done//Verifyregistryisinvalidstatenames:=reg.List()iflen(names)!=10{t.Errorf("Concurrentaccessresultedin%dproviders,want10",len(names))}})}//TestHTTPStreamteststheHTTPstreamimplementationfuncTestHTTPStream(t*testing.T){t.Run("NewHTTPStreamcreatesvalidstream",func(t*testing.T){body:=io.NopCloser(strings.NewReader("data:test\n\n"))resp:=&http.Response{StatusCode:200,Body:body,}stream:=NewHTTPStream(resp)ifstream==nil{t.Fatal("NewHTTPStreamreturnednil")}ifstream.body==nil{t.Error("HTTPStreambodyisnil")}})t.Run("NextreturnschunksuntilEOF",func(t*testing.T){data:="data:chunk1\n\ndata:chunk2\n\n"body:=io.NopCloser(strings.NewReader(data))resp:=&http.Response{StatusCode:200,Body:body,}stream:=NewHTTPStream(resp)//ReadchunksuntilEOFfoundData:=falsefor{chunk,err:=stream.Next()iferr==io.EOF{break}iferr!=nil{t.Fatalf("Next()returnederror:%v",err)}iflen(chunk)>0{foundData=true}}if!foundData{t.Error("Expectedtoreadsomedata")}})t.Run("Closeclosesunderlyingresponsebody",func(t*testing.T){closeCalled:=falsebody:=&mockReadCloser{Reader:strings.NewReader("data:test\n\n"),closeFunc:func()error{closeCalled=truereturnnil},}resp:=&http.Response{StatusCode:200,Body:body,}stream:=NewHTTPStream(resp)err:=stream.Close()iferr!=nil{t.Errorf("Close()returnederror:%v",err)}if!closeCalled{t.Error("Close()didnotclosetheunderlyingbody")}})t.Run("Nexthandlesemptylinescorrectly",func(t*testing.T){//SSEformatwithemptylinesbetweeneventsdata:="\n\ndata:test\n\n\n"body:=io.NopCloser(strings.NewReader(data))resp:=&http.Response{StatusCode:200,Body:body,}stream:=NewHTTPStream(resp)_,err:=stream.Next()//ShouldgetdataorEOFiferr!=nil&&err!=io.EOF{t.Fatalf("Next()returnedunexpectederror:%v",err)}})t.Run("Healthystatusreporting",func(t*testing.T){status:=HealthStatus{Healthy:true,Latency:50*time.Millisecond,LastCheck:time.Now(),Error:"",}if!status.Healthy{t.Error("Statusshouldbehealthy")}ifstatus.Latency!=50*time.Millisecond{t.Errorf("Latency=%v,want50ms",status.Latency)}ifstatus.Error!=""{t.Errorf("Errorshouldbeempty,got:%s",status.Error)}})t.Run("Unhealthystatuswitherror",func(t*testing.T){status:=HealthStatus{Healthy:false,Latency:0,LastCheck:time.Now(),Error:"connectiontimeout",}ifstatus.Healthy{t.Error("Statusshouldbeunhealthy")}ifstatus.Error==""{t.Error("Errormessageshouldbeset")}ifstatus.Error!="connectiontimeout"{t.Errorf("Error=%s,want'connectiontimeout'",status.Error)}})}//TestChatRequesttestschatrequestvalidationfuncTestChatRequest(t*testing.T){t.Run("Validchatrequest",func(t*testing.T){temp:=0.7maxTokens:=100req:=&ChatRequest{Model:"gpt-4",Messages:[]ChatMessage{{Role:"user",Content:"Hello"},},Temperature:&temp,MaxTokens:&maxTokens,Stream:false,}ifreq.Model!="gpt-4"{t.Errorf("Model=%s,wantgpt-4",req.Model)}iflen(req.Messages)!=1{t.Errorf("Messageslength=%d,want1",len(req.Messages))}if*req.Temperature!=0.7{t.Errorf("Temperature=%f,want0.7",*req.Temperature)}})t.Run("Chatrequestwithtools",func(t*testing.T){req:=&ChatRequest{Model:"gpt-4",Messages:[]ChatMessage{{Role:"user",Content:"Test"},},Tools:[]Tool{{Type:"function",Function:Function{Name:"get_weather",Description:"Getweatherdata",},},},}iflen(req.Tools)!=1{t.Errorf("Toolslength=%d,want1",len(req.Tools))}ifreq.Tools[0].Function.Name!="get_weather"{t.Errorf("Functionname=%s,wantget_weather",req.Tools[0].Function.Name)}})t.Run("Streamingchatrequest",func(t*testing.T){req:=&ChatRequest{Model:"gpt-4",Messages:[]ChatMessage{{Role:"user",Content:"Streamtest"}},Stream:true,}if!req.Stream{t.Error("Streamshouldbetrue")}})}//MockProviderisatestimplementationoftheProviderinterfacetypeMockProviderstruct{namestring}func(m*MockProvider)Name()string{returnm.name}func(m*MockProvider)ChatCompletion(ctxcontext.Context,req*ChatRequest)(*ChatResponse,error){return&ChatResponse{ID:"test-id",Model:req.Model,Choices:[]Choice{{Message:ChatMessage{Role:"assistant",Content:"testresponse"}}},},nil}func(m*MockProvider)ChatCompletionStream(ctxcontext.Context,req*ChatRequest)(Stream,error){data:="data:{\"choices\":[{\"delta\":{\"content\":\"test\"}}]}\n\n"body:=io.NopCloser(strings.NewReader(data))resp:=&http.Response{StatusCode:200,Body:body}returnNewHTTPStream(resp),nil}func(m*MockProvider)Embeddings(ctxcontext.Context,req*EmbeddingsRequest)(*EmbeddingsResponse,error){return&EmbeddingsResponse{Data:[]EmbeddingData{{Embedding:[]float64{0.1,0.2,0.3}}},},nil}func(m*MockProvider)HealthCheck(ctxcontext.Context)HealthStatus{returnHealthStatus{Healthy:true,Latency:10*time.Millisecond,LastCheck:time.Now()}}func(m*MockProvider)Models()[]string{return[]string{"model1","model2"}}//mockReadCloserwrapsaReaderandallowstestingClose()behaviortypemockReadCloserstruct{io.ReadercloseFuncfunc()error}func(m*mockReadCloser)Close()error{ifm.closeFunc!=nil{returnm.closeFunc()}returnnil}