packagestreamingimport("bytes""io""sync""sync/atomic""time")//Streamistheminimalinterfaceforreadingchunks.//Compatiblewithprovider.Stream.typeStreaminterface{Next()([]byte,error)Close()error}//ChunkObserverreceivesacopy-freeviewofeachchunk.//Implementationsmustnotretainthebytesliceafterreturning.typeChunkObserverinterface{OnChunk(chunk[]byte,indexint)OnDone(statsStreamStats)}//StreamStatscapturesaggregatemetricsforacompletedstream.typeStreamStatsstruct{TotalChunksintTotalBytesint64EstTokensintDurationtime.DurationFirstChunkAttime.Duration//TimetofirstbyteAvgChunkBytesfloat64PoolHitsint64PoolMissesint64}//───MeteredStream──────────────────────────────────────────//MeteredStreamwrapsaproviderstreamwithmeteringandobserverhooks.//Itusesthebufferpoolforzero-allocationreadsinsteadystate.typeMeteredStreamstruct{innerStreampool*BufferPoolobservers[]ChunkObservermusync.RWMutex//Metrics(atomicforlock-freereads)chunkCountint64totalBytesint64startTimetime.TimefirstChunktime.Time//Stateclosedint32//atomic:0=open,1=closed}//NewMeteredStreamwrapsastreamwithbufferpoolingandobservers.funcNewMeteredStream(innerStream,observers...ChunkObserver)*MeteredStream{return&MeteredStream{inner:inner,pool:ChunkPool,observers:observers,startTime:time.Now(),}}//WithPoolsetsacustombufferpool.func(ms*MeteredStream)WithPool(pool*BufferPool)*MeteredStream{ms.pool=poolreturnms}//AddObserverattachesanobservertoreceivechunkevents.func(ms*MeteredStream)AddObserver(obsChunkObserver){ms.mu.Lock()ms.observers=append(ms.observers,obs)ms.mu.Unlock()}//Nextreadsthenextchunkusingapooledbuffer.//ThereturnedbytesliceisvaliduntilthenextcalltoNext().func(ms*MeteredStream)Next()([]byte,error){ifatomic.LoadInt32(&ms.closed)==1{returnnil,io.EOF}chunk,err:=ms.inner.Next()iferr!=nil{iferr==io.EOF{ms.notifyDone()}returnnil,err}idx:=int(atomic.AddInt64(&ms.chunkCount,1))atomic.AddInt64(&ms.totalBytes,int64(len(chunk)))//Recordfirst-chunktimeifidx==1{ms.firstChunk=time.Now()}//Notifyobservers(zero-copy—observersseechunkdirectly)ms.mu.RLock()for_,obs:=rangems.observers{obs.OnChunk(chunk,idx)}ms.mu.RUnlock()returnchunk,nil}//Closefreesresourcesandnotifiesobservers.func(ms*MeteredStream)Close()error{if!atomic.CompareAndSwapInt32(&ms.closed,0,1){returnnil//Alreadyclosed}ms.notifyDone()returnms.inner.Close()}//Statsreturnsthecurrentstreamingstatistics.func(ms*MeteredStream)Stats()StreamStats{count:=atomic.LoadInt64(&ms.chunkCount)bytes:=atomic.LoadInt64(&ms.totalBytes)duration:=time.Since(ms.startTime)varttfbtime.Durationif!ms.firstChunk.IsZero(){ttfb=ms.firstChunk.Sub(ms.startTime)}varavgBytesfloat64ifcount>0{avgBytes=float64(bytes)/float64(count)}returnStreamStats{TotalChunks:int(count),TotalBytes:bytes,Duration:duration,FirstChunkAt:ttfb,AvgChunkBytes:avgBytes,}}func(ms*MeteredStream)notifyDone(){stats:=ms.Stats()ms.mu.RLock()for_,obs:=rangems.observers{obs.OnDone(stats)}ms.mu.RUnlock()}//───SSEContentExtractor───────────────────────────────────//ExtractSSEContentparsesSSEdatalinesandextractsthecontent//deltafromanOpenAI-compatiblestreamingresponse.Thisenables//token-levelmeteringwithoutfullJSONparsing.////T208:Rewrittentoworkwith[]bytedirectly—eliminatesthe//string(chunk)copy+strings.Splitallocationthatwasthe//highest-frequencyallocinthegateway(50-200×perstream).////Exampleinput:data:{"choices":[{"delta":{"content":"Hello"}}]}//Returns:"Hello"funcExtractSSEContent(chunk[]byte)string{//Scanlineswithoutallocatinga[][]byteslicevarcontentPrefix=[]byte(`"content":"`)vardataPrefix=[]byte("data:")vardoneMarker=[]byte("[DONE]")forlen(chunk)>0{//FindnextlineboundarylineEnd:=bytes.IndexByte(chunk,'\n')varline[]byteiflineEnd==-1{line=chunkchunk=nil}else{line=chunk[:lineEnd]chunk=chunk[lineEnd+1:]}//Trimwhitespacewithoutallocationline=bytes.TrimSpace(line)if!bytes.HasPrefix(line,dataPrefix){continue}data:=line[6:]//skip"data:"ifbytes.Equal(data,doneMarker){continue}//Fastpath:find"content":"withoutfullJSONparseidx:=bytes.Index(data,contentPrefix)ifidx==-1{continue}start:=idx+len(contentPrefix)end:=bytes.IndexByte(data[start:],'"')ifend==-1{continue}//Onlyallocatethefinalcontentstring(unavoidable,neededforreturn)returnstring(data[start:start+end])}return""}//───TokenEstimatingObserver───────────────────────────────//TokenEstimatorisaChunkObserverthatestimatestokensfromSSEchunks.typeTokenEstimatorstruct{totalTokensint64totalChunksint64}//NewTokenEstimatorcreatesatokenestimatorobserver.funcNewTokenEstimator()*TokenEstimator{return&TokenEstimator{}}//OnChunkextractscontentfromSSEandestimatestokens.func(te*TokenEstimator)OnChunk(chunk[]byte,indexint){content:=ExtractSSEContent(chunk)ifcontent==""{return}//Estimate:~4charspertokenforEnglish(sameheuristicasmetering.TokenCounter)tokens:=(len(content)+3)/4atomic.AddInt64(&te.totalTokens,int64(tokens))atomic.AddInt64(&te.totalChunks,1)}//OnDoneiscalledwhenthestreamends.func(te*TokenEstimator)OnDone(statsStreamStats){//No-op;statsareavailableviaEstimatedTokens()}//EstimatedTokensreturnstheestimatedoutputtokencount.func(te*TokenEstimator)EstimatedTokens()int{returnint(atomic.LoadInt64(&te.totalTokens))}//ChunkCountreturnsthenumberofcontent-bearingchunks.func(te*TokenEstimator)ChunkCount()int{returnint(atomic.LoadInt64(&te.totalChunks))}