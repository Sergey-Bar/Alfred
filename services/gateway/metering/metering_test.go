packagemetering_testimport("context""math""sync""testing""time""github.com/AlfredDev/alfred/services/gateway/metering")//──TokenCounter────────────────────────────────────────────funcTestTokenCounter_EmptyString(t*testing.T){tc:=metering.NewTokenCounter(4.0)iftc.EstimateTokens("")!=0{t.Error("emptystringshouldbe0tokens")}}funcTestTokenCounter_ShortText(t*testing.T){tc:=metering.NewTokenCounter(4.0)//"Hello"=5chars/4=1token+3overhead=4result:=tc.EstimateTokens("Hello")ifresult<=0{t.Error("shorttextshouldhave>0tokens")}}funcTestTokenCounter_DefaultRatio(t*testing.T){//Zeroornegativeshouldusedefault4.0tc:=metering.NewTokenCounter(0)result:=tc.EstimateTokens("Helloworld,howareyou?")ifresult<=0{t.Error("defaultratiocountershouldwork")}}funcTestTokenCounter_NegativeRatio(t*testing.T){tc:=metering.NewTokenCounter(-1.0)result:=tc.EstimateTokens("test")ifresult<=0{t.Error("negativeratioshoulddefaultto4.0andwork")}}funcTestTokenCounter_EstimateMessagesTokens(t*testing.T){tc:=metering.NewTokenCounter(4.0)msgs:=[]metering.Message{{Role:"system",Content:"Youareahelpfulassistant."},{Role:"user",Content:"Hello!"},}result:=tc.EstimateMessagesTokens(msgs)ifresult<=0{t.Error("messagestokenestimateshouldbe>0")}}funcTestTokenCounter_MessagesIncludesOverhead(t*testing.T){tc:=metering.NewTokenCounter(4.0)//Singlemessagesingle:=tc.EstimateMessagesTokens([]metering.Message{{Role:"user",Content:"Hi"},})//Samecontent,nomessagesraw:=tc.EstimateTokens("Hi")//Messagesshouldincludeper-messageoverhead+finaloverheadifsingle<=raw{t.Errorf("messages(%d)shouldincludeoverheadbeyondrawtokens(%d)",single,raw)}}funcTestTokenCounter_MessageWithName(t*testing.T){tc:=metering.NewTokenCounter(4.0)withName:=tc.EstimateMessagesTokens([]metering.Message{{Role:"user",Content:"Hello",Name:"Alice"},})withoutName:=tc.EstimateMessagesTokens([]metering.Message{{Role:"user",Content:"Hello"},})ifwithName<=withoutName{t.Error("messagewithnameshouldhavemoretokens")}}//──CostEngine──────────────────────────────────────────────funcTestCostEngine_KnownModel(t*testing.T){ce:=metering.NewCostEngine()//openai/gpt-4o:$2.50/1Minput,$10.00/1Moutputcost:=ce.Calculate("openai","gpt-4o",1000,500)expected:=(1000.0/1_000_000)*2.50+(500.0/1_000_000)*10.00ifmath.Abs(cost-expected)>0.00001{t.Errorf("expectedcost%f,got%f",expected,cost)}}funcTestCostEngine_FreeModel(t*testing.T){ce:=metering.NewCostEngine()cost:=ce.Calculate("groq","llama-3.1-70b",10000,5000)ifcost!=0{t.Errorf("freemodelshouldcost0,got%f",cost)}}funcTestCostEngine_UnknownModel(t*testing.T){ce:=metering.NewCostEngine()cost:=ce.Calculate("unknown","nonexistent",10000,5000)ifcost!=0{t.Errorf("unknownmodelshouldcost0,got%f",cost)}}funcTestCostEngine_IsFree(t*testing.T){ce:=metering.NewCostEngine()if!ce.IsFree("groq/llama-3.1-70b"){t.Error("groq/llama-3.1-70bshouldbefree")}ifce.IsFree("openai/gpt-4o"){t.Error("openai/gpt-4oshouldnotbefree")}}funcTestCostEngine_UpdatePricing(t*testing.T){ce:=metering.NewCostEngine()ce.UpdatePricing("custom","my-model",metering.ModelPrice{InputPer1M:1.00,OutputPer1M:2.00,})cost:=ce.Calculate("custom","my-model",1_000_000,1_000_000)expected:=3.0ifmath.Abs(cost-expected)>0.01{t.Errorf("expectedcost%f,got%f",expected,cost)}}funcTestCostEngine_Estimate_SameAsCalculate(t*testing.T){ce:=metering.NewCostEngine()calc:=ce.Calculate("openai","gpt-4o",500,1000)est:=ce.Estimate("openai","gpt-4o",500,1000)ifcalc!=est{t.Errorf("Estimate(%f)shouldequalCalculate(%f)",est,calc)}}//──StreamMeter─────────────────────────────────────────────funcTestStreamMeter_InputTokens(t*testing.T){tc:=metering.NewTokenCounter(4.0)sm:=metering.NewStreamMeter(tc,100)ifsm.InputTokens()!=100{t.Errorf("expected100inputtokens,got%d",sm.InputTokens())}}funcTestStreamMeter_AddChunk(t*testing.T){tc:=metering.NewTokenCounter(4.0)sm:=metering.NewStreamMeter(tc,100)sm.AddChunk("Helloworld")sm.AddChunk("Anotherchunkoftext")ifsm.OutputTokens()<=0{t.Error("outputtokensshouldincreaseafteraddingchunks")}ifsm.ChunkCount()!=2{t.Errorf("expected2chunks,got%d",sm.ChunkCount())}}funcTestStreamMeter_TotalTokens(t*testing.T){tc:=metering.NewTokenCounter(4.0)sm:=metering.NewStreamMeter(tc,100)sm.AddChunk("someoutputtexthere")total:=sm.TotalTokens()iftotal<=100{t.Error("totalshouldbe>inputtokensafteraddingoutputchunks")}iftotal!=sm.InputTokens()+sm.OutputTokens(){t.Error("totalshouldequalinput+output")}}funcTestStreamMeter_Duration(t*testing.T){tc:=metering.NewTokenCounter(4.0)sm:=metering.NewStreamMeter(tc,0)time.Sleep(10*time.Millisecond)ifsm.Duration()<10*time.Millisecond{t.Error("durationshouldbe>=10ms")}}funcTestStreamMeter_ConcurrentAddChunk(t*testing.T){tc:=metering.NewTokenCounter(4.0)sm:=metering.NewStreamMeter(tc,0)varwgsync.WaitGroupfori:=0;i<100;i++{wg.Add(1)gofunc(){deferwg.Done()sm.AddChunk("chunkdata")}()}wg.Wait()ifsm.ChunkCount()!=100{t.Errorf("expected100chunks,got%d",sm.ChunkCount())}}//──ReservationStore────────────────────────────────────────funcTestReservationStore_Reserve(t*testing.T){rs:=metering.NewReservationStore()r:=rs.Reserve("res-1","wallet-1","user-1","openai","gpt-4o",0.05,500)ifr.ID!="res-1"{t.Errorf("expectedID'res-1',got%q",r.ID)}ifr.Status!="reserved"{t.Errorf("expectedstatus'reserved',got%q",r.Status)}}funcTestReservationStore_Settle(t*testing.T){rs:=metering.NewReservationStore()rs.Reserve("res-1","wallet-1","user-1","openai","gpt-4o",0.05,500)r,err:=rs.Settle("res-1",0.03,300)iferr!=nil{t.Fatalf("settlefailed:%v",err)}ifr.Status!="settled"{t.Errorf("expected'settled',got%q",r.Status)}ifr.ActualCost!=0.03{t.Errorf("expectedactualcost0.03,got%f",r.ActualCost)}ifr.OutputTokens!=300{t.Errorf("expected300outputtokens,got%d",r.OutputTokens)}ifr.SettledAt==nil{t.Error("SettledAtshouldbeset")}}funcTestReservationStore_SettleNotFound(t*testing.T){rs:=metering.NewReservationStore()_,err:=rs.Settle("nonexistent",0.01,100)iferr==nil{t.Error("expectederrorfornonexistentreservation")}}funcTestReservationStore_SettleAlreadySettled(t*testing.T){rs:=metering.NewReservationStore()rs.Reserve("res-1","w","u","openai","gpt-4o",0.05,500)rs.Settle("res-1",0.03,300)_,err:=rs.Settle("res-1",0.03,300)iferr==nil{t.Error("expectederrorwhensettlingalready-settledreservation")}}funcTestReservationStore_Refund(t*testing.T){rs:=metering.NewReservationStore()rs.Reserve("res-1","w","u","openai","gpt-4o",0.05,500)r,err:=rs.Refund("res-1")iferr!=nil{t.Fatalf("refundfailed:%v",err)}ifr.Status!="refunded"{t.Errorf("expected'refunded',got%q",r.Status)}ifr.ActualCost!=0{t.Errorf("refundedcostshouldbe0,got%f",r.ActualCost)}}funcTestReservationStore_RefundNotFound(t*testing.T){rs:=metering.NewReservationStore()_,err:=rs.Refund("nonexistent")iferr==nil{t.Error("expectederrorfornonexistentreservation")}}funcTestReservationStore_Get(t*testing.T){rs:=metering.NewReservationStore()rs.Reserve("res-1","w","u","openai","gpt-4o",0.05,500)r,found:=rs.Get("res-1")if!found{t.Fatal("reservationshouldbefound")}ifr.Provider!="openai"{t.Errorf("expectedprovider'openai',got%q",r.Provider)}}funcTestReservationStore_GetNotFound(t*testing.T){rs:=metering.NewReservationStore()_,found:=rs.Get("nonexistent")iffound{t.Error("nonexistentreservationshouldnotbefound")}}//──AsyncLogger─────────────────────────────────────────────typemockLogWriterstruct{musync.Mutexlogs[]metering.RequestLog}func(m*mockLogWriter)WriteLog(ctxcontext.Context,logmetering.RequestLog)error{m.mu.Lock()deferm.mu.Unlock()m.logs=append(m.logs,log)returnnil}func(m*mockLogWriter)WriteBatch(ctxcontext.Context,logs[]metering.RequestLog)error{m.mu.Lock()deferm.mu.Unlock()m.logs=append(m.logs,logs...)returnnil}funcTestAsyncLogger_LogAndClose(t*testing.T){writer:=&mockLogWriter{}al:=metering.NewAsyncLogger(writer,100)al.Log(metering.RequestLog{RequestID:"req-1",Provider:"openai",Model:"gpt-4o",Cost:0.01,})al.Close()//Flushespendingwriter.mu.Lock()deferwriter.mu.Unlock()iflen(writer.logs)!=1{t.Errorf("expected1logentry,got%d",len(writer.logs))}}funcTestAsyncLogger_BatchFlush(t*testing.T){writer:=&mockLogWriter{}al:=metering.NewAsyncLogger(writer,1000)fori:=0;i<50;i++{al.Log(metering.RequestLog{RequestID:"req",Provider:"openai",})}al.Close()writer.mu.Lock()deferwriter.mu.Unlock()iflen(writer.logs)!=50{t.Errorf("expected50logentries,got%d",len(writer.logs))}}//──SentinelErrors─────────────────────────────────────────funcTestSentinelErrors(t*testing.T){ifmetering.ErrReservationNotFound.Error()!="reservationnotfound"{t.Error("ErrReservationNotFoundmessagemismatch")}ifmetering.ErrReservationAlreadySettled.Error()!="reservationalreadysettled"{t.Error("ErrReservationAlreadySettledmessagemismatch")}ifmetering.ErrInsufficientBalance.Error()!="insufficientwalletbalance"{t.Error("ErrInsufficientBalancemessagemismatch")}}