packageredisclientimport("context""errors""fmt""sync""sync/atomic""time""github.com/AlfredDev/alfred/services/gateway/config""github.com/redis/go-redis/v9""github.com/rs/zerolog")//───CircuitBreakerStates─────────────────────────────────typecircuitStateint32const(stateClosedcircuitState=0//Normal—requestsflowthroughstateOpencircuitState=1//Tripped—requestsshort-circuitstateHalfOpencircuitState=2//Probing—onerequestallowedthrough)func(scircuitState)String()string{switchs{casestateClosed:return"closed"casestateOpen:return"open"casestateHalfOpen:return"half-open"default:return"unknown"}}//───HealthStatus──────────────────────────────────────────//HealthreportsthecurrentRedisconnectionstate.typeHealthstruct{Connectedbool`json:"connected"`CircuitStatestring`json:"circuit_state"`ConsecFailuresint64`json:"consecutive_failures"`TotalFailuresint64`json:"total_failures"`TotalSuccessesint64`json:"total_successes"`LastErrorstring`json:"last_error,omitempty"`LastErrorAttime.Time`json:"last_error_at,omitempty"`LastSuccessAttime.Time`json:"last_success_at,omitempty"`Latencytime.Duration`json:"latency_ns"`UptimePctfloat64`json:"uptime_pct"`DegradedModebool`json:"degraded_mode"`ReconnectAttemptint64`json:"reconnect_attempt"`}//───Configuration──────────────────────────────────────────//CircuitConfigcontrolscircuitbreakerbehavior.typeCircuitConfigstruct{//FailureThresholdtripsthecircuitafterthismanyconsecutivefailures.FailureThresholdint64//HalfOpenTimeoutishowlongthecircuitstaysopenbeforeallowingaprobe.HalfOpenTimeouttime.Duration//OperationTimeoutisthecontexttimeoutforindividualRedisoperations.OperationTimeouttime.Duration//ReconnectIntervalistheminimumtimebetweenbackgroundreconnectattempts.ReconnectIntervaltime.Duration//MaxReconnectBackoffcapsexponentialbackoffforreconnectionattempts.MaxReconnectBackofftime.Duration}//DefaultCircuitConfigreturnsproductiondefaults.funcDefaultCircuitConfig()CircuitConfig{returnCircuitConfig{FailureThreshold:5,HalfOpenTimeout:30*time.Second,OperationTimeout:2*time.Second,ReconnectInterval:5*time.Second,MaxReconnectBackoff:2*time.Minute,}}//───Client─────────────────────────────────────────────────//Clientwrapsgo-rediswithcircuitbreaker,healthmonitoring,//andgracefuldegradation.WhenRedisisunavailable,Getreturns//("",false,nil),Set/Delreturnnil,andExistsreturns(false,nil).//CallersneverneedtohandleRedisconnectionfailures.typeClientstruct{c*redis.Clientloggerzerolog.Logger//CircuitbreakercircuitCfgCircuitConfigstateatomic.Int32//circuitStateconsecFailatomic.Int64totalFailatomic.Int64totalOKatomic.Int64trippedAtatomic.Int64//unixnanowhencircuitopenedreconnAttemptatomic.Int64//Healthtrackingmusync.RWMutexlastErrerrorlastErrAttime.TimelastOKAttime.Timeconnectedatomic.Bool//LifecyclestopChchanstruct{}wgsync.WaitGroup}//NewcreatesaRedisclientwithcircuitbreakerfromtheprovidedconfig.//ReturnsanerroronlyiftheRedisURLisunparseable.Apingfailure//doesNOTpreventcreation—theclientstartsindegradedmodeand//reconnectsinthebackground.funcNew(cfg*config.Config,loggerzerolog.Logger,circuitCfg...CircuitConfig)(*Client,error){opt,err:=redis.ParseURL(cfg.RedisURL)iferr!=nil{returnnil,fmt.Errorf("invalidREDIS_URL:%w",err)}cc:=DefaultCircuitConfig()iflen(circuitCfg)>0{cc=circuitCfg[0]}cl:=&Client{c:redis.NewClient(opt),logger:logger.With().Str("component","redis").Logger(),circuitCfg:cc,stopCh:make(chanstruct{}),}//Attemptinitialconnectionctx,cancel:=context.WithTimeout(context.Background(),cc.OperationTimeout)defercancel()iferr:=cl.c.Ping(ctx).Err();err!=nil{cl.logger.Warn().Err(err).Msg("redisinitialpingfailed—startingindegradedmode")cl.recordFailure(err)}else{cl.connected.Store(true)cl.mu.Lock()cl.lastOKAt=time.Now()cl.mu.Unlock()cl.logger.Info().Msg("redisconnected")}//Startbackgroundhealthmonitorcl.wg.Add(1)gocl.reconnectLoop()returncl,nil}//───DataOperations(GracefulDegradation)─────────────────//Getretrievesavaluebykey.Returns("",false,nil)oncachemiss//orwhenRedisisunavailable.Thebooleanindicateswhetheravalue//wasfound.Errorsareneverreturnedtocallers—degradationis//handledinternally.func(cl*Client)Get(ctxcontext.Context,keystring)(string,bool,error){if!cl.allowRequest(){return"",false,nil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()val,err:=cl.c.Get(opCtx,key).Result()iferr!=nil{iferrors.Is(err,redis.Nil){cl.recordSuccess()return"",false,nil//Cachemiss—notanerror}cl.recordFailure(err)return"",false,nil//Connectionerror—degradegracefully}cl.recordSuccess()returnval,true,nil}//Setstoresakey-valuepairwithTTL.ReturnsnilevenwhenRedisis//unavailable—thecaller'sin-memoryfallbackhandlesstorage.func(cl*Client)Set(ctxcontext.Context,key,valuestring,ttltime.Duration)error{if!cl.allowRequest(){returnnil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()err:=cl.c.Set(opCtx,key,value,ttl).Err()iferr!=nil{cl.recordFailure(err)returnnil//Degradegracefully}cl.recordSuccess()returnnil}//Delremovesoneormorekeys.Returns0whenRedisisunavailable.func(cl*Client)Del(ctxcontext.Context,keys...string)(int64,error){if!cl.allowRequest(){return0,nil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()n,err:=cl.c.Del(opCtx,keys...).Result()iferr!=nil{cl.recordFailure(err)return0,nil}cl.recordSuccess()returnn,nil}//Existschecksifakeyexists.ReturnsfalsewhenRedisisunavailable.func(cl*Client)Exists(ctxcontext.Context,keystring)(bool,error){if!cl.allowRequest(){returnfalse,nil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()n,err:=cl.c.Exists(opCtx,key).Result()iferr!=nil{cl.recordFailure(err)returnfalse,nil}cl.recordSuccess()returnn>0,nil}//SetNXsetsakeyonlyifitdoesnotexist(distributedlockprimitive).//ReturnsfalsewhenRedisisunavailable.func(cl*Client)SetNX(ctxcontext.Context,key,valuestring,ttltime.Duration)(bool,error){if!cl.allowRequest(){returnfalse,nil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()ok,err:=cl.c.SetNX(opCtx,key,value,ttl).Result()iferr!=nil{cl.recordFailure(err)returnfalse,nil}cl.recordSuccess()returnok,nil}//Incratomicallyincrementsakey.Returns0whenRedisisunavailable.func(cl*Client)Incr(ctxcontext.Context,keystring)(int64,error){if!cl.allowRequest(){return0,nil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()n,err:=cl.c.Incr(opCtx,key).Result()iferr!=nil{cl.recordFailure(err)return0,nil}cl.recordSuccess()returnn,nil}//ExpiresetsaTTLonanexistingkey.No-opwhenRedisisunavailable.func(cl*Client)Expire(ctxcontext.Context,keystring,ttltime.Duration)error{if!cl.allowRequest(){returnnil}opCtx,cancel:=context.WithTimeout(ctx,cl.circuitCfg.OperationTimeout)defercancel()err:=cl.c.Expire(opCtx,key,ttl).Err()iferr!=nil{cl.recordFailure(err)returnnil}cl.recordSuccess()returnnil}//───Health&Lifecycle─────────────────────────────────────//PingperformsaRedisPINGcommandwithoutcircuitbreakerprotection.//Usedforhealthchecksandreadinessprobes.func(cl*Client)Ping()error{ctx,cancel:=context.WithTimeout(context.Background(),cl.circuitCfg.OperationTimeout)defercancel()returncl.c.Ping(ctx).Err()}//HealthreturnsastructuredhealthreportfortheRedisconnection.func(cl*Client)Health()Health{cl.mu.RLock()varlastErrStrstringvarlastErrAttime.TimevarlastOKtime.Timeifcl.lastErr!=nil{lastErrStr=cl.lastErr.Error()lastErrAt=cl.lastErrAt}lastOK=cl.lastOKAtcl.mu.RUnlock()totalOK:=cl.totalOK.Load()totalFail:=cl.totalFail.Load()total:=totalOK+totalFailvaruptimePctfloat64iftotal>0{uptimePct=float64(totalOK)/float64(total)*100}st:=circuitState(cl.state.Load())isConnected:=cl.connected.Load()//Measurecurrentlatencyvarlatencytime.DurationifisConnected&&st!=stateOpen{start:=time.Now()ctx,cancel:=context.WithTimeout(context.Background(),cl.circuitCfg.OperationTimeout)err:=cl.c.Ping(ctx).Err()cancel()iferr==nil{latency=time.Since(start)}}returnHealth{Connected:isConnected,CircuitState:st.String(),ConsecFailures:cl.consecFail.Load(),TotalFailures:totalFail,TotalSuccesses:totalOK,LastError:lastErrStr,LastErrorAt:lastErrAt,LastSuccessAt:lastOK,Latency:latency,UptimePct:uptimePct,DegradedMode:st!=stateClosed,ReconnectAttempt:cl.reconnAttempt.Load(),}}//IsHealthyreturnstruewhenthecircuitisclosedandRedisisreachable.func(cl*Client)IsHealthy()bool{returncl.connected.Load()&&circuitState(cl.state.Load())==stateClosed}//CloseshutsdownthebackgroundreconnectloopandclosestheRedisconnection.func(cl*Client)Close()error{close(cl.stopCh)cl.wg.Wait()returncl.c.Close()}//───CircuitBreakerLogic──────────────────────────────────//allowRequestdecideswhetheraRedisoperationshouldproceed.//Returnsfalse(gracefuldegradation)whenthecircuitisopen.func(cl*Client)allowRequest()bool{st:=circuitState(cl.state.Load())switchst{casestateClosed:returntruecasestateOpen://Checkifenoughtimehaspassedtotryhalf-opentrippedNano:=cl.trippedAt.Load()elapsed:=time.Since(time.Unix(0,trippedNano))ifelapsed>=cl.circuitCfg.HalfOpenTimeout{//Transitiontohalf-open—allowoneproberequestifcl.state.CompareAndSwap(int32(stateOpen),int32(stateHalfOpen)){cl.logger.Info().Msg("rediscircuithalf-open—probing")returntrue}}returnfalsecasestateHalfOpen://Onlyonerequestatatimeinhalf-open;othersdegradereturnfalsedefault:returnfalse}}//recordSuccessmarksasuccessfulRedisoperation.func(cl*Client)recordSuccess(){cl.totalOK.Add(1)cl.consecFail.Store(0)cl.connected.Store(true)cl.mu.Lock()cl.lastOKAt=time.Now()cl.mu.Unlock()st:=circuitState(cl.state.Load())ifst==stateHalfOpen{//Recoveryconfirmed—closethecircuitcl.state.Store(int32(stateClosed))cl.reconnAttempt.Store(0)cl.logger.Info().Msg("rediscircuitclosed—recovered")}}//recordFailuremarksafailedRedisoperationandmaytripthecircuit.func(cl*Client)recordFailure(errerror){n:=cl.consecFail.Add(1)cl.totalFail.Add(1)cl.mu.Lock()cl.lastErr=errcl.lastErrAt=time.Now()cl.mu.Unlock()st:=circuitState(cl.state.Load())ifst==stateHalfOpen{//Probefailed—reopenthecircuitcl.state.Store(int32(stateOpen))cl.trippedAt.Store(time.Now().UnixNano())cl.connected.Store(false)cl.logger.Warn().Err(err).Msg("redisprobefailed—circuitreopened")return}ifn>=cl.circuitCfg.FailureThreshold&&st==stateClosed{cl.state.Store(int32(stateOpen))cl.trippedAt.Store(time.Now().UnixNano())cl.connected.Store(false)cl.logger.Error().Err(err).Int64("consecutive_failures",n).Msg("rediscircuitOPEN—enteringdegradedmode")}}//───BackgroundReconnection────────────────────────────────//reconnectLooprunsinthebackgroundandperiodicallyattemptsto//reconnectwhenthecircuitisopen.Usesexponentialbackoff.func(cl*Client)reconnectLoop(){defercl.wg.Done()baseInterval:=cl.circuitCfg.ReconnectIntervalmaxBackoff:=cl.circuitCfg.MaxReconnectBackofffor{//Calculatebackoff:base*2^attempt,cappedatmaxBackoffattempt:=cl.reconnAttempt.Load()backoff:=baseIntervalfori:=int64(0);i<attempt&&backoff<maxBackoff;i++{backoff*=2}ifbackoff>maxBackoff{backoff=maxBackoff}select{case<-cl.stopCh:returncase<-time.After(backoff):}st:=circuitState(cl.state.Load())ifst==stateClosed{//Alreadyhealthy—justmonitorcontinue}//Attemptreconnectioncl.reconnAttempt.Add(1)ctx,cancel:=context.WithTimeout(context.Background(),cl.circuitCfg.OperationTimeout)err:=cl.c.Ping(ctx).Err()cancel()iferr!=nil{cl.logger.Debug().Err(err).Int64("attempt",cl.reconnAttempt.Load()).Dur("next_backoff",backoff*2).Msg("redisreconnectfailed")continue}//Pingsucceeded—transitiontohalf-openifstillopenifcl.state.CompareAndSwap(int32(stateOpen),int32(stateHalfOpen)){cl.logger.Info().Msg("redisreconnectpingsucceeded—circuithalf-open")//Thenextrealoperationwillclosethecircuitonsuccess}}}